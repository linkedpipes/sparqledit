import { CleanOntologyClassTextFormatter } from "../../src/Ontology/OntologyClassTextFormatter";
import { OntologyAssertions } from "../../src/Ontology/OntologyAssertions";
import { AtomicClass, UnknownClass, RestrictionClass, IntersectionClass, UnionClass, ComplementClass } from "../../src/Ontology/OntologyClass";
import * as chai from "chai";

describe("OntologyClassTextFormatter", () => {
    it("should compute complex formatting", () => {
        var ac1 = new AtomicClass("http://example.org/test1");
        var ac2 = new AtomicClass("http://example.org/test2");
        var ac3 = new ComplementClass(new AtomicClass("http://example.org/test3"));
        var unkc1 = new UnknownClass("unkown");

        var inc1 = (new IntersectionClass())
            .addClass(ac1)
            .addClass(ac2);

        var unc1 = new UnionClass()
            .addClass(ac2)
            .addClass(ac3);

        var resc1 = new RestrictionClass("http://example.org/test5");

        var finalClass = new UnionClass()
            .addClass(inc1)
            .addClass(unc1)
            .addClass(resc1)
            .addClass(unkc1);

        var expectedResultSimple = "UnionOf(IntersectionOf(Atomic(http://example.org/test1), " +
            "Atomic(http://example.org/test2)), UnionOf(Atomic(http://example.org/test2), " +
            "ComplementOf(Atomic(http://example.org/test3))), RestrictionOn(http://example.org/test5), Unknown(unkown))";

        chai.expect(finalClass.getText()).equal(expectedResultSimple);
        // should run
        finalClass.getText(new CleanOntologyClassTextFormatter());
    });
});

