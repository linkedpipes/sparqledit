import { TurtleGraphWrapper } from '../../../src/GraphTools/TurtleGraphWrapper';
import { OntologyHierarchyBuilder } from '../../../src/Ontology/Algorithms/OntologyHierarchyBuilder';
import { OntologyAssertionsBuilder } from '../../../src/Ontology/Algorithms/OntologyAssertionBuilder';
import { OntologyAutocompleteSubProvider } from '../../../src/Autocompletition/SubProviders/OntologyAutocompleteSubProvider';
import { Block, NodeType } from '../../../src/Autocompletition/Query/Query';
import { SparqlLanguageServerSettings } from '../../../src/Autocompletition/SparqlLanguageServerSettings';
import { createOntologyHierarchyFromTurtle } from '../../../test/Utils/Utils';

import * as chai from 'chai';
import { ERSParser } from 'ERSParser';
var rdf = require('rdf');

var ontologyAssertionsBuilder = new OntologyAssertionsBuilder();
var ontologyHiarchyBuilder = new OntologyHierarchyBuilder();

function parseQuery(queryContent: string) {
    var parser = new ERSParser();
    return parser.parse(queryContent).query;
}

describe('OntologyAutocompleteSubProvider', () => {
    it('should do simple autocomplettion', () => {
        var hiearchySchemaContent = require('raw-loader!../../TestData/Autocompletition/SubProviders/schema.ttl');
        var queryContent = require('raw-loader!../../TestData/Autocompletition/SubProviders/query.sparql');

        var ontologyHierachy = createOntologyHierarchyFromTurtle(hiearchySchemaContent);
        var autocompleteProvider = new OntologyAutocompleteSubProvider(ontologyHierachy, new SparqlLanguageServerSettings({}));
        var query = parseQuery(queryContent);
        var autocompleteResult = autocompleteProvider.provideAutocompleteItems(query);
    })

    describe('Block', () => {
        it('should parse different kinds of nodes.', () => {
            var queryContent = require('raw-loader!../../TestData/Autocompletition/SubProviders/queryBlock.sparql');

            var query: any = parseQuery(queryContent);
            var block = new Block(query.where[0].triples);
            var objects = block.triples.map(x =>
                ({
                    type: NodeType[x.object.type],
                    value: x.object.value
                }));
        })
    });
})