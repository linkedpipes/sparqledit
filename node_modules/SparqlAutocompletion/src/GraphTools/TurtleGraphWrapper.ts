import { IRDFNode, IGraph, ITriple } from "./GraphInterfaces";
import { SimpleGraph } from "./SimpleGraph";
var rdf = require("rdf");
var N3 = require("n3");

export class TurtleGraphWrapper implements IGraph {

    private graph: any;
    constructor(private turtleSchema: string, private forbiddenSources: string[] = []) {
        this.graph = this.parseTurtle();
    }

    public graphSources: string[] = [];

    private parseTurtle() {
        var environment = new rdf.RDFEnvironment();
        var parser = N3.Parser();
        function proccessNode(nodeValue: string) {
            if (nodeValue.substr(0, 2) == "_:") {
                return new rdf.BlankNode(nodeValue);
            }
            else if (nodeValue.substr(0, 4) == "http") {
                return environment.createNamedNode(nodeValue);
            }
            else {
                return environment.createLiteral(nodeValue);
            }
        }

        var graph = environment.createGraph();
        try {
            var triples = parser.parse(this.turtleSchema);
            triples.forEach((triple: any) => {
                if (!this.graphSources.some(x => x == triple.graph)) {
                    this.graphSources.push(triple.graph);
                }
                if (this.forbiddenSources.filter(x => triple.graph == x).length == 0) {
                    graph.add(environment.createTriple(
                        proccessNode(triple.subject),
                        proccessNode(triple.predicate),
                        proccessNode(triple.object)));
                }
            });
        }
        catch (e) {
            throw new Error("Parser problem" + e);
        }
        // TODO: Check for nulls
        return graph;
    }

    getTriples(): ITriple[] {
        return this.graph.match(null, null, null);
    }

    public match(subject: any, predicate: any, object: any) {
        return new SimpleGraph(this.graph.match(subject, predicate, object));
    }

    anyObject(subject: string, predicate: string): IRDFNode {
        return this.graph.match(subject, predicate, null)[0].object;
    }

    eachObject(subject: string, predicate: string): IRDFNode[] {
        var result = this.graph.match(subject, predicate, null)
            .map((x: any) => x.object);
        return result;
    }


    public getCollection(subject: string) {
        return this.graph.getCollection(subject);
    }

    public containsAny(): boolean {
        throw new Error("Method not implemented.");
    }

    public getFirst(): ITriple {
        throw new Error("Method not implemented.");
    }

    getTriplesCount(): number {
        throw new Error("Method not implemented.");
    }

}