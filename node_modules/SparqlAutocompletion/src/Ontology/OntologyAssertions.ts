import { IOntologyClass, AtomicClass } from "..";
import { Dictionary } from "lodash";
import { StringDictionary, NumberDictionary } from "../Collections/Dictionary";
import { OntologyLabel } from "./OntologyLabel";
import * as _ from "lodash";

class OntologyClassUtils {
    static Contains(ontologyClasses: IOntologyClass[], checkOntologyClass: IOntologyClass) {
        return _(ontologyClasses).some((x: IOntologyClass) => x.getText() == checkOntologyClass.getText());
    }
}

export class OntologyProperty {

    public domains: IOntologyClass[] = [];

    public ranges: IOntologyClass[] = [];

    public label = new OntologyLabel();

    constructor(public name: string) {

    }

    public addDomain(domain: IOntologyClass) {
        if (OntologyClassUtils.Contains(this.domains, domain)) {
            return;
        }
        this.domains.push(domain);
    }

    public addRange(range: IOntologyClass) {
        if (OntologyClassUtils.Contains(this.ranges, range)) {
            return;
        }
        this.ranges.push(range);
    }
}

class DomainClassIndex {
    private domainDictionary: Dictionary<OntologyProperty[]> = {};

    public addPropertyIndexByDomain(domain: IOntologyClass, property: OntologyProperty) {
        var classText = domain.getText();
        var domainItem = this.domainDictionary[classText];
        if (domainItem) {
            var currentPropertyName = property.name;
            if (!_(domainItem).some((x: OntologyProperty) => x.name == currentPropertyName)) {
                domainItem.push(property);
            }
        }
        else {
            this.domainDictionary[classText] = [property];
        }
    }

    public findPropertyByDomain(domain: IOntologyClass) {
        var result = this.domainDictionary[domain.getText()];
        if (result == undefined) {
            return [];
        }
        return result;
    }
}

export class OntologyAssertions {

    private _classes: IOntologyClass[] = [];

    private _classDictionary: StringDictionary<number> = {};

    private domainClassIndex: DomainClassIndex = new DomainClassIndex();

    private _subClassEdges: { superClass: number, subsetClass: number }[] = [];

    private _subClassEdgesDictionary: NumberDictionary<number[]> = [];

    private propertiesDictionary: Dictionary<OntologyProperty> = {};

    load(classes: IOntologyClass[],
        subClassEdges: { superClass: number, subsetClass: number }[],
        ontologyProperties: OntologyProperty[]) {

        this._classes = classes;
        this._subClassEdges = subClassEdges;
        this.buildDictionaries(ontologyProperties);
    }

    buildDictionaries(ontologyProperties: OntologyProperty[]) {
        var classDictionary: StringDictionary<number> = {};
        this.classes.forEach((ontologyClass, index) => classDictionary[ontologyClass.getText()] = index);
        this._classDictionary = classDictionary;

        var subClassEdgesDictionary: { [superClass: number]: number[] } = [];
        this.subClassEdges.forEach((edge: { superClass: number, subsetClass: number }) => {
            if (subClassEdgesDictionary[edge.subsetClass] == undefined) {
                subClassEdgesDictionary[edge.subsetClass] = [edge.superClass];
            }
            else {
                subClassEdgesDictionary[edge.subsetClass].push(edge.superClass);
            }
        });
        this._subClassEdgesDictionary = subClassEdgesDictionary;

        var propertiesDictionary: StringDictionary<OntologyProperty> = {};
        ontologyProperties.forEach(property => {
            property.domains.forEach(domain => {
                this.domainClassIndex.addPropertyIndexByDomain(domain, property);
            });
            propertiesDictionary[property.name] = property;
        });
        this.propertiesDictionary = propertiesDictionary;
    }

    public get properties(): OntologyProperty[] {
        var properties = [];
        for (var propertyKey in this.propertiesDictionary) {
            properties.push(this.propertiesDictionary[propertyKey]);
        }
        return properties;
    }

    public get classes(): ReadonlyArray<IOntologyClass> {
        return this._classes;
    }

    public get classDictionary(): Readonly<StringDictionary<number>> {
        return this._classDictionary;
    }

    public get subClassEdges(): ReadonlyArray<{ superClass: number, subsetClass: number }> {
        return this._subClassEdges;
    }

    private addOrGetProperty(propertyName: string) {
        var foundedProperty = this.findPropertyByName(propertyName);
        if (foundedProperty != null) {
            return foundedProperty;
        }
        var newProperty = new OntologyProperty(propertyName);
        this.propertiesDictionary[propertyName] = newProperty;
        return newProperty;
    }

    /**
     *  Returns index of class. If no class match returns -1.
     */
    public findClass(schemaClass: IOntologyClass) {
        var currentClass = this._classDictionary[schemaClass.getText()];
        if (currentClass === undefined) {
            return -1;
        }
        return currentClass;
    }

    public findClassByIri(classIri: string): IOntologyClass {
        var schemaClass = new AtomicClass(classIri);
        var currentClass = this._classDictionary[schemaClass.getText()];
        if (currentClass == null) {
            return null;
        }
        return this._classes[currentClass];
    }

    /**
     * Adds class and returns the class index. If class already exists returns class index and no class is added. 
     * @param schemaClass 
     */
    public addOrGetClassIndex(schemaClass: IOntologyClass) {
        var findedClassIndex = this.findClass(schemaClass);
        if (findedClassIndex != -1) {
            return findedClassIndex;
        }
        this._classDictionary[schemaClass.getText()] = this._classes.length;
        this._classes.push(schemaClass);
        return this._classes.length - 1;
    }

    public findPropertyByName(propertyName: string) {
        var result = this.propertiesDictionary[propertyName];
        if (result == undefined) {
            return null;
        }
        return result;
    }

    public findPropertiesByDomain(domain: IOntologyClass) {
        return this.domainClassIndex.findPropertyByDomain(domain);
    }

    public findSuperSetClasses(subsetClass: IOntologyClass) {
        var subsetClassIndex = this.findClass(subsetClass);
        if (subsetClassIndex == -1) {
            return [];
        }

        var edges = this._subClassEdgesDictionary[subsetClassIndex];
        if (edges == null) {
            return [];
        }

        return edges.map(x => this.classes[x]);
    }

    public existSubclassEdgeOntologyClass(subsetClass: IOntologyClass, superClass: IOntologyClass) {
        return this.existSubclassEdge(this.findClass(subsetClass), this.findClass(superClass));
    }

    public existSubclassEdge(subsetClass: number, superClass: number) {
        var edges = this._subClassEdgesDictionary[subsetClass];
        if (edges == undefined) {
            return false;
        }
        return edges.some(x => x == superClass);
    }

    public addSubclassEdge(subsetClass: IOntologyClass, superClass: IOntologyClass) {
        var subsetClassIndex = this.addOrGetClassIndex(subsetClass);
        var superClassIndex = this.addOrGetClassIndex(superClass);

        if (!this.existSubclassEdge(subsetClassIndex, superClassIndex)) {
            this._subClassEdges.push({ superClass: superClassIndex, subsetClass: subsetClassIndex });
            var edges = this._subClassEdgesDictionary[subsetClassIndex];
            if (edges == undefined) {
                this._subClassEdgesDictionary[subsetClassIndex] = [superClassIndex];
            }
            else {
                edges.push(superClassIndex);
            }
        }
    }

    public addEquivalenceEdge(firstClass: IOntologyClass, secondClass: IOntologyClass) {
        this.addSubclassEdge(firstClass, secondClass);
        this.addSubclassEdge(secondClass, firstClass);
    }

    public addDomain(propertyName: string, domain: IOntologyClass) {
        var innerDomainIndex = this.addOrGetClassIndex(domain);
        var innerDomain = this._classes[innerDomainIndex];
        var property = this.addOrGetProperty(propertyName);
        property.addDomain(innerDomain);
        this.domainClassIndex.addPropertyIndexByDomain(innerDomain, property);
    }

    public addRange(propertyName: string, range: IOntologyClass) {
        var innerRangeIndex = this.addOrGetClassIndex(range);
        var innerRange = this._classes[innerRangeIndex];

        var property = this.addOrGetProperty(propertyName);
        property.addRange(innerRange);
    }
}