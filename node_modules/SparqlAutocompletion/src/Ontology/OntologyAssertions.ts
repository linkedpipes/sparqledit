import { OntologyLabel } from './OntologyLabel';
import { AtomicClass, IOntologyClass } from './OntologyClass';

export class OntologyProperty {

    public domain: IOntologyClass = null;

    public range: IOntologyClass = null;

    public label = new OntologyLabel();

    constructor(public name: string) {

    }
}

export class OntologyAssertions {

    public classes: IOntologyClass[] = [];

    public classDictionary: { [key: string]: number } = {};

    public domainDictionary: { [key: string]: OntologyProperty[] } = {};

    public subClassEdges: { superClass: number, subsetClass: number }[] = [];

    public subClassEdgesDictionary: { [superClass: number]: number[] } = [];

    public properties: OntologyProperty[] = [];

    public propertiesDictionary: { [key: string]: OntologyProperty } = {};

    public addPropertyToDomainDictionary(property: OntologyProperty) {
        if (!property.domain) {
            return;
        }
        var classText = property.domain.getText();
        if (this.domainDictionary[classText]) {
            this.domainDictionary[classText].push(property);
        }
        else {
            this.domainDictionary[classText] = [property];
        }
    }

    private addOrGetProperty(propertyName: string) {
        var foundedProperty = this.findPropertyByName(propertyName);
        if (foundedProperty != null) {
            return foundedProperty;
        }
        var newProperty = new OntologyProperty(propertyName);
        this.properties.push(newProperty);
        this.propertiesDictionary[propertyName] = newProperty;
        return newProperty;
    }

    /**
     *  Returns index of class. If no class match returns -1.
     */
    public findClass(schemaClass: IOntologyClass) {
        var schemaSignature = schemaClass.getText();
        var currentClass = this.classDictionary[schemaClass.getText()];
        if (currentClass === undefined) {
            return -1;
        }
        return currentClass;
    }

    public findClassByIri(classIri: string): IOntologyClass {
        var schemaClass = new AtomicClass(classIri);
        var schemaSignature = schemaClass.getText();
        var currentClass = this.classDictionary[schemaClass.getText()];
        if (currentClass == null) {
            return null;
        }
        return this.classes[currentClass];
    }

    /**
     * Adds class and returns the class index. If class already exists returns class index and no class is added. 
     * @param schemaClass 
     */
    public addOrGetClassIndex(schemaClass: IOntologyClass) {
        var findedClassIndex = this.findClass(schemaClass);
        if (findedClassIndex != -1) {
            return findedClassIndex;
        }
        this.classDictionary[schemaClass.getText()] = this.classes.length;
        this.classes.push(schemaClass);
        return this.classes.length - 1;
    }

    public findPropertyByName(propertyName: string) {
        var result = this.propertiesDictionary[propertyName];
        if (result == undefined) {
            return null;
        }
        return result;
    }

    public findPropertiesByDomain(domain: IOntologyClass) {
        var result = this.domainDictionary[domain.getText()];
        if (result == undefined) {
            return []
        }
        return result;
    }

    public findPropertiesByRange(range: IOntologyClass) {
        return this.properties.filter(x => x.range != null && x.range.equal(range));
    }

    public existSubclassEdgeOntologyClass(subsetClass: IOntologyClass, superClass: IOntologyClass) {
        return this.existSubclassEdge(this.findClass(subsetClass), this.findClass(superClass));
    }

    public existSubclassEdge(subsetClass: number, superClass: number) {
        var edges = this.subClassEdgesDictionary[superClass];
        if (edges == undefined) {
            return false;
        }
        return edges.some(x => x == subsetClass);
    }

    public addSubclassEdge(subsetClass: IOntologyClass, superClass: IOntologyClass) {
        var subsetClassIndex = this.addOrGetClassIndex(subsetClass);
        var superClassIndex = this.addOrGetClassIndex(superClass);

        if (!this.existSubclassEdge(subsetClassIndex, superClassIndex)) {
            this.subClassEdges.push({ superClass: superClassIndex, subsetClass: subsetClassIndex });
            var edges = this.subClassEdgesDictionary[superClassIndex];
            if (edges == undefined) {
                this.subClassEdgesDictionary[superClassIndex] = [subsetClassIndex];
            }
            else {
                edges.push(subsetClassIndex);
            }
        }
    }

    public addEquivalenceEdge(firstClass: IOntologyClass, secondClass: IOntologyClass) {
        this.addSubclassEdge(firstClass, secondClass);
        this.addSubclassEdge(secondClass, firstClass);
    }

    public addDomain(propertyName: string, domain: IOntologyClass) {
        this.addOrGetClassIndex(domain);
        var property = this.addOrGetProperty(propertyName);
        property.domain = domain;
        this.addPropertyToDomainDictionary(property);
    }

    public addRange(propertyName: string, range: IOntologyClass) {
        this.addOrGetClassIndex(range);
        var property = this.addOrGetProperty(propertyName);
        property.range = range;
    }
}