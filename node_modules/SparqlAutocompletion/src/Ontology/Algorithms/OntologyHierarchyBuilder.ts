import { OntologyAssertions } from '../OntologyAssertions';
import { OntologyHierarchy } from '../OntologyHierarchy';
import { OntologyConcept } from "../OntologyConcept";

var scc = require("strongly-connected-components")

interface IStronglyConnectedComponentAlgorithmResult {
    adjacencyList: number[][];
    components: number[][];
}

interface IStronglyConnectedComponentAlgorithm {
    compute(subclassOfEdges: { superClass: number, subsetClass: number }[], nodeCount: number): IStronglyConnectedComponentAlgorithmResult
}

class SccLibAlgorithmWrapper implements IStronglyConnectedComponentAlgorithm {
    private convertEdgesToAdjacentList(subclassEdges: ReadonlyArray<{ superClass: number, subsetClass: number }>, nodeCount: number) {
        var result: number[][] = new Array(nodeCount);
        for (var i = 0; i < nodeCount; i++) {
            result[i] = [];
        }
        for (var edge of subclassEdges) {
            result[edge.subsetClass].push(edge.superClass);
        }
        return result;
    }

    compute(subclassEdges: ReadonlyArray<{ superClass: number, subsetClass: number }>, nodeCount: number): IStronglyConnectedComponentAlgorithmResult {
        var adjacencyList = this.convertEdgesToAdjacentList(subclassEdges, nodeCount);
        var res = scc(adjacencyList);
        return res;
    }
}


export function buildOntologyHierarchy(ontologyAssertions: OntologyAssertions) {
    var stronglyConnectedComponentAlgorithm = new SccLibAlgorithmWrapper();
    var strongComponentGraph = stronglyConnectedComponentAlgorithm.compute(ontologyAssertions.subClassEdges, ontologyAssertions.classes.length);

    var components = strongComponentGraph.components;
    var adjacencyList = strongComponentGraph.adjacencyList;

    var result = new OntologyHierarchy();
    result.ontologyAssertions = ontologyAssertions;
    for (var component of components) {
        var classesInCurrentComponent = component.map((x) => ontologyAssertions.classes[x]);
        result.addConcept(new OntologyConcept(classesInCurrentComponent));
    }

    for (var i = 0; i < adjacencyList.length; i++) {
        adjacencyList[i].forEach((x) => result.addSubclassOfEdge(i, x));
    }

    return result;
}