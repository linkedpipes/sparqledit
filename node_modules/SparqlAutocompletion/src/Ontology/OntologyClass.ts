import { OntologyLabel } from "./OntologyLabel";
import { IOntologyClassTextFormatter, SimpleOntologyClassTextFormatter } from "./OntologyClassTextFormatter";

var simpleOntologyClassTextFormatter = new SimpleOntologyClassTextFormatter();

export interface IOntologyClass {
    getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string;
    equal(ontologyClass: IOntologyClass): boolean;
    label: OntologyLabel;
    getClassName(): string;
}

export abstract class BaseOntologyClass implements IOntologyClass {
    public label = new OntologyLabel();

    abstract getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string;
    abstract equal(ontologyClass: IOntologyClass): boolean;
    abstract getClassName(): string;
}

export class UnknownClass extends BaseOntologyClass {

    constructor(public nodeValue: string) {
        super();
    }

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatUnknownClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return (ontologyClass instanceof UnknownClass) && this.nodeValue == (<UnknownClass>ontologyClass).nodeValue;
    }

    public getClassName(): string {
        return "UnknownClass";
    }
}

export class AtomicClass extends BaseOntologyClass {

    constructor(public iri: string) {
        super();
    }

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatAtomicClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return (ontologyClass instanceof AtomicClass) && this.iri == (<AtomicClass>ontologyClass).iri;
    }

    public getClassName(): string {
        return "AtomicClass";
    }
}

export class RestrictionClass extends BaseOntologyClass {
    constructor(public onProperty: string) {
        super();
    }

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatRestrictionClass(this);
    }

    equal(ontologyClass: IOntologyClass): boolean {
        return (ontologyClass instanceof RestrictionClass) && this.onProperty == (<RestrictionClass>ontologyClass).onProperty;
    }

    public getClassName(): string {
        return "RestrictionClass";
    }
}

export abstract class ListClass extends BaseOntologyClass {

    public classes: IOntologyClass[] = [];

    private areClassSetsEqual(firstClasses: IOntologyClass[], secondClasses: IOntologyClass[]): boolean {
        // Under asumptions that does not contain duplicities
        if (firstClasses.length != secondClasses.length) {
            return false;
        }

        for (var firstClass of firstClasses) {
            if (!secondClasses.some(x => x.equal(firstClass))) {
                return false;
            }
        }

        return true;
    }

    protected equalGeneric<T extends ListClass>(ontologyClass: IOntologyClass, type: { new(): T }): boolean {
        if (!(ontologyClass instanceof type)) {
            return false;
        }

        var firstClasses = this.classes;
        var secondClasses = (<T>ontologyClass).classes;
        return this.areClassSetsEqual(firstClasses, secondClasses);
    }

    public addClass(ontologyClass: IOntologyClass) {
        if (this.classes.some(x => x.equal(ontologyClass))) {
            return this;
        }
        this.classes.push(ontologyClass);
        return this;
    }

    public abstract getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string;

    public abstract equal(ontologyClass: IOntologyClass): boolean;
}

export class IntersectionClass extends ListClass {

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatIntersectionClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return this.equalGeneric(ontologyClass, IntersectionClass);
    }

    public getClassName(): string {
        return "IntersectionClass";
    }
}

export class UnionClass extends ListClass {
    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }

        return ontologyClassTextFormatter.formatUnionClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return this.equalGeneric(ontologyClass, UnionClass);
    }

    public getClassName(): string {
        return "UnionClass";
    }
}

export class ComplementClass extends BaseOntologyClass {

    constructor(public value: IOntologyClass) {
        super();
    }

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatComplementClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return (ontologyClass instanceof ComplementClass) && this.value.equal((<ComplementClass>ontologyClass).value);
    }

    public getClassName(): string {
        return "ComplementClass";
    }
}