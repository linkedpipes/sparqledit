import { IOntologyClassTextFormatter, SimpleOntologyClassTextFormatter } from "./OntologyClassTextFormatter";

var simpleOntologyClassTextFormatter = new SimpleOntologyClassTextFormatter();

export interface IOntologyClass {
    getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string
    equal(ontologyClass: IOntologyClass): boolean
}

export class UnknownClass implements IOntologyClass {

    constructor(public nodeValue: string) {

    }

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatUnknownClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return (ontologyClass instanceof UnknownClass) && this.nodeValue == (<UnknownClass>ontologyClass).nodeValue;
    }
}

export class AtomicClass implements IOntologyClass {

    constructor(public iri: string) {

    }

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatAtomicClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return (ontologyClass instanceof AtomicClass) && this.iri == (<AtomicClass>ontologyClass).iri;
    }
}

export class RestrictionClass implements IOntologyClass {
    constructor(public onProperty: string) {

    }

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatRestrictionClass(this);
    }

    equal(ontologyClass: IOntologyClass): boolean {
        return (ontologyClass instanceof RestrictionClass) && this.onProperty == (<RestrictionClass>ontologyClass).onProperty;
    }

}

export abstract class ListClass implements IOntologyClass {

    public classes: IOntologyClass[] = [];

    private areClassSetsEqual(firstClasses: IOntologyClass[], secondClasses: IOntologyClass[]): boolean {
        // Under asumptions that does not contain duplicities
        if (firstClasses.length != secondClasses.length) {
            return false;
        }

        for (var firstClass of firstClasses) {
            if (!secondClasses.some(x => x.equal(firstClass))) {
                return false;
            }
        }

        return true;
    }

    protected equalGeneric<T extends ListClass>(ontologyClass: IOntologyClass, type: { new (): T }): boolean {
        if (!(ontologyClass instanceof type)) {
            return false;
        }

        var firstClasses = this.classes;
        var secondClasses = (<T>ontologyClass).classes;
        return this.areClassSetsEqual(firstClasses, secondClasses);
    }

    public addClass(ontologyClass: IOntologyClass) {
        if (this.classes.some(x => x.equal(ontologyClass))) {
            return this;
        }
        this.classes.push(ontologyClass);
        return this;
    }

    public abstract getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string;

    public abstract equal(ontologyClass: IOntologyClass): boolean
}

export class IntersectionClass extends ListClass {

    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }
        return ontologyClassTextFormatter.formatIntersectionClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return this.equalGeneric(ontologyClass, IntersectionClass);
    }
}

export class UnionClass extends ListClass {
    public getText(ontologyClassTextFormatter?: IOntologyClassTextFormatter): string {
        if (!ontologyClassTextFormatter) {
            ontologyClassTextFormatter = simpleOntologyClassTextFormatter;
        }

        return ontologyClassTextFormatter.formatUnionClass(this);
    }

    public equal(ontologyClass: IOntologyClass): boolean {
        return this.equalGeneric(ontologyClass, UnionClass);
    }
}