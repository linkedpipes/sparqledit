import { SparqlAutocompleteItemKind, SparqlAutocompleteItem } from "../SparqlAutocompleteProvider";
import { AutocompleteSubProvider } from "./AutocompleteSubProvider";
import { QueryAdviceInferencer } from "../Inference/QueryAdviceInferencer";
import { AutocompleteContext } from "../AutocompleteContext";
import { SparqlLanguageServerSettings } from "../SparqlLanguageServerSettings";
import { ILogger } from "../../Logging/Logger";
import { OntologyAssertions } from "../../Ontology/OntologyAssertions";
import * as _ from "lodash";

export class OntologyAutocompleteSubProvider implements AutocompleteSubProvider {

    constructor(
        private logger: ILogger,
        private ontologyAssertions: OntologyAssertions,
        private sparqlLanguageServerSettings: SparqlLanguageServerSettings) {
        // empty
    }

    provideAutocompleteItems(context: AutocompleteContext): SparqlAutocompleteItem[] {
        var ontologyInferencer = new QueryAdviceInferencer(
            this.logger,
            this.ontologyAssertions,
            this.sparqlLanguageServerSettings.getAdviseAtomicClassFromComplexClass(),
            this.sparqlLanguageServerSettings.getParentOntologyClassTracking());

        try {
            var cursorContext = ontologyInferencer.inferVariableAdvices(context.queryWithCursorParserResult.query, "cursor");
        } catch (e) {
            this.logger.log("Autocomplete broken.");
            return [];
        }

        if (cursorContext == null) {
            return [];
        }

        return _.uniq(cursorContext.getStringQueryAdvices()).map((x: string) => {
            var insertText = x.match(/^http:\/\//) ? "<" + x + ">" : x;

            return {
                label: x,
                kind: SparqlAutocompleteItemKind.Property,
                insertText: insertText,
                filterText: insertText,
            };
        });
    }
}