import { AutocompleteSubProvider, AutocompleteSubProviderContext } from './AutocompleteSubProvider';
import { SparqlAutocompleteItem, SparqlAutocompleteItemKind } from "../SparqlAutocompleteProvider";
import { GetAllProps } from '../../Ontology/Algorithms/GetAllProps';
import { AtomicClass, IOntologyClass } from '../../Ontology/OntologyClass';
import { OntologyHiearchy } from '../../Ontology/OntologyHierchy';
import { RdfIri } from '../../Utils/RdfIri';
import * as _ from 'lodash';

var escapeStringRegexp = require('escape-string-regexp');

export class VariableTypeItem {
    public possibleClasses: IOntologyClass[] = [];
    public possibleAdvices: string[] = [];

    constructor(public name: string) {

    }
}

export class AutocompleteContext {
    public variables: VariableTypeItem[] = [];
    public prefixes: { [key: string]: string } = {};

    getVariableContext(name: string) {
        var matchedVariables = this.variables.filter(x => x.name == name);
        var length = matchedVariables.length;
        if (length > 1) {
            throw new Error();
        }
        if (length == 0) {
            return null;
        }
        return matchedVariables[0];
    }
}

export enum NodeType {
    Iri,
    Blank,
    Variable,
    Literal,
}

export class Node {
    private _originalValue: string;
    private _value: string;
    private _type: NodeType;

    public get originalValue() {
        return this._originalValue;
    }

    public get value() {
        return this._value;
    }

    public get type() {
        return this._type;
    }

    constructor(nodeValue: string) {
        this._originalValue = nodeValue;
        // TODO test the method especially substring
        var startChar = nodeValue.substr(0, 1);
        if (startChar === "?" || startChar === "$") {
            //variable
            this._type = NodeType.Variable;
            this._value = nodeValue.substring(1, nodeValue.length);
        } else if (startChar === "\"") {
            //literal
            this._type = NodeType.Literal;
            this._value = nodeValue;
        } else if (nodeValue.substr(0, 2) === "_:") {
            // blank node
            this._type = NodeType.Blank;
            this._value = nodeValue.substring(2, nodeValue.length);
        } else {
            // iri 
            this._type = NodeType.Iri;
            this._value = nodeValue;
        }
    }
}

export class Triple {
    public subject: Node;
    public predicate: Node;
    public object: Node;

    constructor(subject: string,
        predicate: string,
        object: string) {

        this.subject = new Node(subject);
        this.predicate = new Node(predicate);
        this.object = new Node(object);
    }

    getAllNodes() {
        return [this.subject, this.predicate, this.object];
    }
}

export class Block {
    public triples: Triple[];

    constructor(queryBlock: any) {
        this.triples = queryBlock.map((x: any) =>
            new Triple(x.subject,
                x.predicate,
                x.object)
        );
    }

    matchNode(node: Node, value: string) {
        if (value == null) {
            return true;
        }

        return node.originalValue == value;
    }

    match(subject: string, predicate: string, object: string) {
        var result = this.triples.filter(x => {
            return this.matchNode(x.subject, subject) &&
                this.matchNode(x.predicate, predicate) &&
                this.matchNode(x.object, object);
        });
        return result;
    }
}

export class OntologyAutocompleteSubProvider implements AutocompleteSubProvider {

    private getAllProps: GetAllProps;

    constructor(private ontologyHiearchy: OntologyHiearchy) {
        this.getAllProps = new GetAllProps(ontologyHiearchy);
    }

    private extractAllVariablesNames(block: Block) {
        var result = _(block.triples).map(x => x.getAllNodes())
            .flatten()
            .filter((x: Node) => x.type == NodeType.Variable)
            .map((x: Node) => x.value)
            .uniq()
            .value();
        return result;
    }

    private createContext(block: Block, prefixes: { [key: string]: string }) {
        var variableNames = this.extractAllVariablesNames(block);
        var context = new AutocompleteContext();
        for (var variableName of variableNames) {
            context.variables.push(new VariableTypeItem(variableName));
        }
        context.prefixes = prefixes;
        return context;
    }

    private findAllRdfType(block: Block) {
        var matchedTriples = block.match(null, RdfIri.rdfType, null);
        return matchedTriples
            .filter(x => x.subject.type == NodeType.Variable &&
                x.object.type == NodeType.Iri)
            .map(x => ({
                variableName: x.subject.value,
                classIri: x.object.value
            }));
    }


    private setVariableType(context: AutocompleteContext, variableName: string, ontologyClass: IOntologyClass) {
        var variableContext = context.getVariableContext(variableName);
        variableContext.possibleClasses.push(ontologyClass);
    }

    private propertyNodeSetVariable(context: AutocompleteContext, subjectOrObject: Node, domainOrRange: IOntologyClass) {
        if (subjectOrObject.type == NodeType.Variable && domainOrRange != null) {
            this.setVariableType(context, subjectOrObject.value, domainOrRange)
        }
    }

    private doAllInference(context: AutocompleteContext, block: Block) {
        //  rdfType inrerenece 
        var rdfTypes = this.findAllRdfType(block);
        rdfTypes.forEach(x => this.setVariableType(context, x.variableName, new AtomicClass(x.classIri)));

        for (var triple of block.triples) {
            if (triple.predicate.type == NodeType.Iri) {
                var currentPropertyName = this.ontologyHiearchy.ontologyAssertions.findPropertyByName(triple.predicate.value);
                if (currentPropertyName != null) {
                    this.propertyNodeSetVariable(context, triple.subject, currentPropertyName.domain);
                    this.propertyNodeSetVariable(context, triple.object, currentPropertyName.range);
                }
            }
        }
    }

    private addRdfTypeAdvices(context: AutocompleteContext, block: Block) {
        var matchedTriples = block.match(null, RdfIri.rdfType, null);

        for (var matchedTriple of matchedTriples) {
            if (matchedTriple.object.type == NodeType.Variable) {
                var allAtomicClasses = this.ontologyHiearchy.ontologyAssertions.classes
                    .filter(x => (x instanceof AtomicClass))
                    .map(x => (<AtomicClass>x).iri);
                var variableAdvices = context.getVariableContext(matchedTriple.object.value).possibleAdvices;
                allAtomicClasses = this.processPrefixesInIri(context.prefixes, allAtomicClasses);
                allAtomicClasses.forEach(x => variableAdvices.push(x));

            }
        }
    }

    private processPrefixesInIri(prefixes: { [key: string]: string }, advices: string[]): string[] {
        if (!prefixes) {
            return advices;
        }

        console.log(advices.length);
        return advices.map(iri => {
            for (var prefix in prefixes) {
                var prefixValue = prefixes[prefix];
                iri = iri.replace(new RegExp("^" + escapeStringRegexp(prefixValue)), prefix + ":");
            }
            return iri;
        });
    }

    private addAllAdvices(context: AutocompleteContext, block: Block) {
        for (var variable of context.variables) {
            if (variable.possibleClasses.length > 0) {
                // TODO extend for all classes
                var classConcept = this.ontologyHiearchy.getConceptContainsOntologyClass(variable.possibleClasses[0]);
                var computedProps = this.getAllProps.doAlgorithm(classConcept);

                var chucked = computedProps.getPropertiesByChunk();
                var ress = _(chucked).map(x => ({
                    name: x.concept
                        .ontologyClasses
                        .map(x => x.getText()).join(','),
                    props: x.properties
                })).map(x => x.props.map(y => x.name + '  ' + y.name))
                    .flatten<string>()
                    .value();

                var newAdvices = computedProps.getAllPoperties().map(x => x.name);
                // var newAdvices = ress;
                newAdvices = this.processPrefixesInIri(context.prefixes, newAdvices);
                var matchedTriples = block.match('?' + variable.name, null, null);
                for (var triple of matchedTriples) {
                    if (triple.predicate.type == NodeType.Variable) {
                        var currentAdvices = context.getVariableContext(triple.predicate.value).possibleAdvices;
                        newAdvices.forEach(x => currentAdvices.push(x));
                    }
                }
            }
        }
    }

    doAutocomplete(query: any) {
        var queryBlock = query.where[0].triples;
        var block = new Block(queryBlock);
        var context = this.createContext(block, query.prefixes);
        this.doAllInference(context, block);
        this.addRdfTypeAdvices(context, block);
        this.addAllAdvices(context, block);
        return context;
    }

    provideAutocompleteItems(context: AutocompleteSubProviderContext): SparqlAutocompleteItem[] {
        try {
            var result = this.doAutocomplete(context.queryWithCursorParserResult.query);
        } catch (e) {
            console.log("Autocomplete broken.");
            return [];
        }

        var cursorContext = result.getVariableContext('cursor');
        if (cursorContext != null) {
            return cursorContext.possibleAdvices.map((x: string) => {
                // TODO: can be better
                var insertText = x.match(/^http:\/\//) ? '<' + x + '>' : x;

                return {
                    label: x,
                    kind: SparqlAutocompleteItemKind.Property,
                    insertText: insertText,
                    filterText: insertText,
                }
            });
        }
        return [];
    }
}