import { OntologyHierarchy } from '../../Ontology/OntologyHierarchy';
import { SparqlAutocompleteItemKind, SparqlAutocompleteItem } from '../SparqlAutocompleteProvider';
import { AutocompleteSubProvider } from './AutocompleteSubProvider';
import { QueryAdviceInferencer } from "../Inference/QueryAdviceInferencer";
import { AutocompleteContext } from '../AutocompleteContext';
import { SparqlLanguageServerSettings } from '../SparqlLanguageServerSettings';

export class OntologyAutocompleteSubProvider implements AutocompleteSubProvider {

    constructor(private ontologyHierarchy: OntologyHierarchy, private sparqlLanguageServerSettings: SparqlLanguageServerSettings) {
        // empty
    }

    provideAutocompleteItems(context: AutocompleteContext): SparqlAutocompleteItem[] {
        var ontologyInferencer = new QueryAdviceInferencer(this.sparqlLanguageServerSettings.getPropertySelectorType(), this.ontologyHierarchy);

        try {
            var cursorContext = ontologyInferencer.inferVariableAdvices(context.queryWithCursorParserResult.query, 'cursor');
        } catch (e) {
            console.log("Autocomplete broken.");
            return [];
        }

        if (cursorContext != null) {
            return cursorContext.getStringQueryAdvices().map((x: string) => {
                // TODO: can be better
                var insertText = x.match(/^http:\/\//) ? '<' + x + '>' : x;

                return {
                    label: x,
                    kind: SparqlAutocompleteItemKind.Property,
                    insertText: insertText,
                    filterText: insertText,
                }
            });
        }
        return [];
    }
}