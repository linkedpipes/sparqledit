import { Block, Node, NodeType } from '../Query/Query';
import { injectCursor } from '../Utils/QueryTerminalInjection';
import { OntologyProperty } from '../../Ontology/OntologyAssertions';
import { AutocompleteSubProvider, AutocompleteSubProviderContext } from './AutocompleteSubProvider';
import { SparqlAutocompleteItem, SparqlAutocompleteItemKind } from '../SparqlAutocompleteProvider';
import { FullPropertySelector } from '../PropertySelector/FullPropertySelector';
import { RestrictedPropertySelector } from '../PropertySelector/RestrictedPropertySelector';
import { IOntologyClass, AtomicClass } from '../../Ontology/OntologyClass';
import { OntologyConcept, OntologyHiearchy } from '../../Ontology/OntologyHierchy';
import { RdfIri } from '../../Utils/RdfIri';
import * as _ from 'lodash';
import { ERSParser } from "ERSParser";

var escapeStringRegexp = require('escape-string-regexp');

export class VariableTypeItem {
    public possibleClasses: IOntologyClass[] = [];
    public possibleAdvices: string[] = [];
    public possibleAdvicesStructured: { concept: OntologyConcept, properties: OntologyProperty[] }[]

    constructor(public name: string) {

    }
}

export class AutocompleteContext {
    public variables: VariableTypeItem[] = [];
    public prefixes: { [key: string]: string } = {};

    getVariableContext(name: string) {
        var matchedVariables = this.variables.filter(x => x.name == name);
        var length = matchedVariables.length;
        if (length > 1) {
            throw new Error();
        }
        if (length == 0) {
            return null;
        }
        return matchedVariables[0];
    }
}


export class OntologyAutocompleteSubProvider implements AutocompleteSubProvider {

    // private getAllProps: GetAllProps;
    private getAllProps: RestrictedPropertySelector;

    constructor(private ontologyHiearchy: OntologyHiearchy) {
        this.getAllProps = new RestrictedPropertySelector(ontologyHiearchy);
        // this.getAllProps = new GetAllProps(ontologyHiearchy);
    }

    private extractAllVariablesNames(block: Block) {
        var result = _(block.triples).map(x => x.getAllNodes())
            .flatten()
            .filter((x: Node) => x.type == NodeType.Variable)
            .map((x: Node) => x.value)
            .uniq()
            .value();
        return result;
    }

    private createContext(block: Block, prefixes: { [key: string]: string }) {
        var variableNames = this.extractAllVariablesNames(block);
        var context = new AutocompleteContext();
        for (var variableName of variableNames) {
            context.variables.push(new VariableTypeItem(variableName));
        }
        context.prefixes = prefixes;
        return context;
    }

    private findAllRdfType(block: Block) {
        var matchedTriples = block.match(null, RdfIri.rdfType, null);
        return matchedTriples
            .filter(x => x.subject.type == NodeType.Variable &&
                x.object.type == NodeType.Iri)
            .map(x => ({
                variableName: x.subject.value,
                classIri: x.object.value
            }));
    }


    private setVariableType(context: AutocompleteContext, variableName: string, ontologyClass: IOntologyClass) {
        var variableContext = context.getVariableContext(variableName);
        variableContext.possibleClasses.push(ontologyClass);
    }

    private propertyNodeSetVariable(context: AutocompleteContext, subjectOrObject: Node, domainOrRange: IOntologyClass) {
        if (subjectOrObject.type == NodeType.Variable && domainOrRange != null) {
            this.setVariableType(context, subjectOrObject.value, domainOrRange)
        }
    }

    private doAllInference(context: AutocompleteContext, block: Block) {
        //  rdfType inrerenece 
        var rdfTypes = this.findAllRdfType(block);
        rdfTypes.forEach(x => this.setVariableType(context, x.variableName, new AtomicClass(x.classIri)));

        for (var triple of block.triples) {
            if (triple.predicate.type == NodeType.Iri) {
                var currentPropertyName = this.ontologyHiearchy.ontologyAssertions.findPropertyByName(triple.predicate.value);
                if (currentPropertyName != null) {
                    this.propertyNodeSetVariable(context, triple.subject, currentPropertyName.domain);
                    this.propertyNodeSetVariable(context, triple.object, currentPropertyName.range);
                }
            }
        }
    }

    private addRdfTypeAdvices(context: AutocompleteContext, block: Block) {
        var matchedTriples = block.match(null, RdfIri.rdfType, null);

        for (var matchedTriple of matchedTriples) {
            if (matchedTriple.object.type == NodeType.Variable) {
                var allAtomicClasses = this.ontologyHiearchy.ontologyAssertions.classes
                    .filter(x => (x instanceof AtomicClass))
                    .map(x => (<AtomicClass>x).iri);
                var variableAdvices = context.getVariableContext(matchedTriple.object.value).possibleAdvices;
                allAtomicClasses = this.processPrefixesInIri(context.prefixes, allAtomicClasses);
                allAtomicClasses.forEach(x => variableAdvices.push(x));
            }
        }
    }

    private processPrefixesInIri(prefixes: { [key: string]: string }, advices: string[]): string[] {
        if (!prefixes) {
            return advices;
        }

        return advices.map(iri => {
            for (var prefix in prefixes) {
                var prefixValue = prefixes[prefix];
                iri = iri.replace(new RegExp("^" + escapeStringRegexp(prefixValue)), prefix + ":");
            }
            return iri;
        });
    }

    private addAllAdvices(context: AutocompleteContext, block: Block) {
        for (var variable of context.variables) {
            if (variable.possibleClasses.length > 0) {
                // TODO extend for all classes
                // var classConcept = this.ontologyHiearchy.getConceptContainsOntologyClass(variable.possibleClasses[0]);
                // var computedProps = this.getAllProps.doAlgorithm(classConcept);
                var computedProps = this.getAllProps.doAlgorithm(variable.possibleClasses[0]);

                var chucked = computedProps.getPropertiesByChunk();

                var ress = _(chucked).map(x => ({
                    name: x.concept
                        .ontologyClasses
                        .map(x => x.getText()).join(','),
                    props: x.properties
                })).map(x => x.props.map(y => x.name + '  ' + y.name))
                    .flatten<string>()
                    .value();

                var newAdvices = computedProps.getAllPoperties().map(x => x.name);
                // var newAdvices = ress;
                newAdvices = this.processPrefixesInIri(context.prefixes, newAdvices);
                var matchedTriples = block.match('?' + variable.name, null, null);
                for (var triple of matchedTriples) {
                    if (triple.predicate.type == NodeType.Variable) {
                        var currentAdvices = context.getVariableContext(triple.predicate.value).possibleAdvices;
                        newAdvices.forEach(x => currentAdvices.push(x));
                        context.getVariableContext(triple.predicate.value).possibleAdvicesStructured = chucked;
                    }
                }
            }
        }
    }

    doAutocomplete(query: any) {
        var queryBlock = query.where[0].triples;
        var block = new Block(queryBlock);
        var context = this.createContext(block, query.prefixes);
        this.doAllInference(context, block);
        this.addRdfTypeAdvices(context, block);
        this.addAllAdvices(context, block);
        return context;
    }

    providePropertyAutocompletion(queryContent: string, cursorOffset: number) {
        try {
            var queryWithCursor = injectCursor(queryContent, cursorOffset);
            var parser = new ERSParser();
            var result = this.doAutocomplete(parser.parse(queryWithCursor).query);
        } catch (e) {
            console.log(e);
            return null;
        }

        var cursorContext = result.getVariableContext('cursor');
        if (cursorContext == null) {
            return null;
        }

        return cursorContext.possibleAdvicesStructured;
    }

    provideAutocompleteItems(context: AutocompleteSubProviderContext): SparqlAutocompleteItem[] {
        try {
            var result = this.doAutocomplete(context.queryWithCursorParserResult.query);
        } catch (e) {
            console.log("Autocomplete broken.");
            return [];
        }

        var cursorContext = result.getVariableContext('cursor');
        if (cursorContext != null) {
            return cursorContext.possibleAdvices.map((x: string) => {
                // TODO: can be better
                var insertText = x.match(/^http:\/\//) ? '<' + x + '>' : x;

                return {
                    label: x,
                    kind: SparqlAutocompleteItemKind.Property,
                    insertText: insertText,
                    filterText: insertText,
                }
            });
        }
        return [];
    }
}