import { OntologyHierarchy } from '../../Ontology/OntologyHierarchy';
import { SparqlAutocompleteItemKind, SparqlAutocompleteItem } from '../SparqlAutocompleteProvider';
import { AutocompleteSubProvider } from './AutocompleteSubProvider';
import { QueryAdviceInferencer } from "../Inference/QueryAdviceInferencer";
import { AutocompleteContext } from '../AutocompleteContext';
import { SparqlLanguageServerSettings } from '../SparqlLanguageServerSettings';
import { ILogger } from '../../Logging/Logger';

export class OntologyAutocompleteSubProvider implements AutocompleteSubProvider {

    constructor(
        private logger: ILogger,
        private ontologyHierarchy: OntologyHierarchy,
        private sparqlLanguageServerSettings: SparqlLanguageServerSettings) {
        // empty
    }

    provideAutocompleteItems(context: AutocompleteContext): SparqlAutocompleteItem[] {
        var ontologyInferencer = new QueryAdviceInferencer(
            this.logger,
            this.ontologyHierarchy,
            this.sparqlLanguageServerSettings.getPropertySelectorType());

        try {
            var cursorContext = ontologyInferencer.inferVariableAdvices(context.queryWithCursorParserResult.query, 'cursor');
        } catch (e) {
            this.logger.log("Autocomplete broken.");
            return [];
        }

        if (cursorContext == null) {
            return [];
        }
        
        return cursorContext.getStringQueryAdvices().map((x: string) => {
            var insertText = x.match(/^http:\/\//) ? '<' + x + '>' : x;

            return {
                label: x,
                kind: SparqlAutocompleteItemKind.Property,
                insertText: insertText,
                filterText: insertText,
            }
        });
    }
}