import { AutocompleteSubProvider, AutocompleteSubProviderContext } from './AutocompleteSubProvider';
import { SparqlAutocompleteItem, SparqlAutocompleteItemKind } from "../SparqlAutocompleteProvider";

interface IKeywordDefinition {
    terminal: string
    insertText: string
}

export class KeywordAutocompleteSubProvider implements AutocompleteSubProvider {

    private supportedKeywordsDefinitions: IKeywordDefinition[] = [
        { terminal: "ADD", insertText: "add" },
        { terminal: "ALL", insertText: "all" },
        { terminal: "AS", insertText: "as" },
        { terminal: "ASC", insertText: "asc" },
        { terminal: "ASK", insertText: "ask" },
        { terminal: "BASE", insertText: "base" },
        { terminal: "BIND", insertText: "bind" },
        { terminal: "BY", insertText: "by" },
        { terminal: "CLEAR", insertText: "clear" },
        { terminal: "CONSTRUCT", insertText: "construct" },
        { terminal: "COPY", insertText: "copy" },
        { terminal: "CREATE", insertText: "create" },
        { terminal: "DEFAULT", insertText: "default" },
        { terminal: "DELETE", insertText: "delete" },
        { terminal: "DELETEDATA", insertText: "delete data" },
        { terminal: "DELETEWHERE", insertText: "delete where" },
        { terminal: "DESC", insertText: "desc" },
        { terminal: "DESCRIBE", insertText: "describe" },
        { terminal: "DISTINCT", insertText: "distinct" },
        { terminal: "DROP", insertText: "drop" },
        { terminal: "EXISTS", insertText: "exists" },
        { terminal: "FILTER", insertText: "filter" },
        { terminal: "FROM", insertText: "from" },
        { terminal: "GRAPH", insertText: "graph" },
        { terminal: "GROUP", insertText: "group" },
        { terminal: "HAVING", insertText: "having" },
        { terminal: "IN", insertText: "in" },
        { terminal: "INSERT", insertText: "insert" },
        { terminal: "INSERTDATA", insertText: "insert data" },
        { terminal: "INTO", insertText: "into" },
        { terminal: "LIMIT", insertText: "limit" },
        { terminal: "LOAD", insertText: "load" },
        { terminal: "MINUS", insertText: "minus" },
        { terminal: "MOVE", insertText: "move" },
        { terminal: "NAMED", insertText: "named" },
        { terminal: "NOT", insertText: "not" },
        { terminal: "OFFSET", insertText: "offset" },
        { terminal: "OPTIONAL", insertText: "optional" },
        { terminal: "ORDER", insertText: "order" },
        { terminal: "PREFIX", insertText: "prefix" },
        { terminal: "REDUCED", insertText: "reduced" },
        { terminal: "SELECT", insertText: "select" },
        { terminal: "SEPARATOR", insertText: "separator" },
        { terminal: "SERVICE", insertText: "service" },
        { terminal: "SILENT", insertText: "silent" },
        { terminal: "TO", insertText: "to" },
        { terminal: "UNDEF", insertText: "undef" },
        { terminal: "UNION", insertText: "union" },
        { terminal: "USING", insertText: "using" },
        { terminal: "VALUES", insertText: "values" },
        { terminal: "WHERE", insertText: "where" },
        { terminal: "WITH", insertText: "with" }]

    provideAutocompleteItems(context: AutocompleteSubProviderContext): SparqlAutocompleteItem[] {

        var errorWithBreaker = context
            .queryWithBreakerParserResult
            .extraTracedParserErrors
            .filter(x => x.problemToken == "BREAKER");

        if (errorWithBreaker.length == 0) {
            return [];
        }

        var expectedTokens = errorWithBreaker[0].expected;

        // filter only keywords that are expected

        var currentKeywords: IKeywordDefinition[] = this.supportedKeywordsDefinitions
            .filter(x => expectedTokens.filter((y: any) => y == x.terminal).length > 0);

        return currentKeywords.map(x => ({
            label: x.insertText,
            kind: SparqlAutocompleteItemKind.Keyword,
            insertText: x.insertText
        }));
    }
}