import { AutocompleteSubProvider } from "./AutocompleteSubProvider";
import { SparqlAutocompleteItem, SparqlAutocompleteItemKind } from "../SparqlAutocompleteProvider";
import { AutocompleteContext } from "../AutocompleteContext";

class VariableAccumulator {
    variables: string[] = [];

    containsVariable(variableName: string) {
        return this.variables.filter(x => x == variableName).length > 0;
    }
    private forbiddenVariableNames(variableName: string) {
        return variableName == "cursor" ||
            variableName == "object" ||
            variableName == "error" ||
            variableName == "predicate";
    }
    addVariable(variableName: string) {
        if (!this.forbiddenVariableNames(variableName) &&
            variableName.length > 0 &&
            !this.containsVariable(variableName)) {
            this.variables.push(variableName);
        }
    }
}

export class VariableAutocompleteSubProvider implements AutocompleteSubProvider {

    // TODO maybe should be implementet together with ontologyautocomplete 
    findAllVariablesNames(query: any): string[] {
        if (query == null) {
            return [];
        }
        var variableAccumulator = new VariableAccumulator();
        this.recursiveQuerySearch(variableAccumulator, query);
        return variableAccumulator.variables;
    }

    private recursiveQuerySearch(variableAccumulator: VariableAccumulator, queryPart: any) {
        if (typeof (queryPart) === "string") {
            if (queryPart.match(/^\?/)) {
                variableAccumulator.addVariable(queryPart.substring(1));
            }
        }
        else if (queryPart instanceof Array) {
            for (var i = 0; i < queryPart.length; i++) {
                this.recursiveQuerySearch(variableAccumulator, queryPart[i]);
            }
        } else if (queryPart instanceof Object) {
            for (var property in queryPart) {
                this.recursiveQuerySearch(variableAccumulator, queryPart[property]);
            }
        }
        // do nothing 
    }

    provideAutocompleteItems(context: AutocompleteContext): SparqlAutocompleteItem[] {
        var errorWithBreaker = context
            .queryWithBreakerParserResult
            .extraTracedParserErrors
            .filter(x => x.problemToken == "BREAKER");

        if (errorWithBreaker.length == 0) {
            return [];
        }

        var expectedTokens = errorWithBreaker[0].expected;

        if (!expectedTokens.filter((x: any) => x == "VAR")) {
            return [];
        }

        return this
            .findAllVariablesNames(context.queryWithCursorParserResult)
            .map(x => ({
                label: x,
                kind: SparqlAutocompleteItemKind.Variable,
                insertText: "?" + x,
                filterText: "?" + x
            }));
    }
}