import { OntologyHiearchyBuilder } from '../Ontology/Algorithms/OntologyHiearchyBuilder';
import { OntologyAssertionsBuilder } from '../Ontology/Algorithms/OntologyAssertionBuilder';
import { TurtleGraphWrapper } from '../GraphTools/TurtleGraphWrapper';
import { OntologyHiearchy } from '../Ontology/OntologyHierchy';
import { OntologyAutocompleteSubProvider, AutocompleteContext } from "./SubProviders/OntologyAutocompleteSubProvider";
import { ERSParser } from "ERSParser";

export interface SparqlAutocompleteItem {
    label: string,
    insertText: string;
}

export class SparqlAutocompleteProvider {
    constructor(private ontologyContent: string) {
        // empty
        console.log('Start preparing ontology hiearchy.')
        this.ontologyHiearchy = this.createOntologyHiearchyFromFile();
        console.log('Ontology hiearchy prepared.')
    }


    private ontologyAssertionsBuilder = new OntologyAssertionsBuilder();
    private ontologyHiarchyBuilder = new OntologyHiearchyBuilder();
    private ontologyHiearchy: OntologyHiearchy;

    triggerCharacters: string[] = [];


    takeWhileNotWhitespace(text: string) {
        for (var i = text.length - 1; i >= 0; i--) {
            if (text[i] == " ") {
                return text.substr(0, i);
            }
        }

        return "";
    }

    removeCharactersAfterCursor(text: string) {
        for (var i = 0; i < text.length; i++) {
            var currentCharacter = text[i];
            if (currentCharacter == '\n' || currentCharacter == '\r') {
                return '.' + text.substring(i, text.length);
            }
        }

        return "";
    }

    injectCursor(query: string, offset: number) {
        return this.injectTerminal(query, offset, "cursor");
    }

    injectUnknown(query: string, offset: number) {
        return this.injectTerminal(query, offset, "unknown");
    }

    injectTerminal(query: string, offset: number, terminal: string) {
        var beforeCursor = query.substring(0, offset);
        var atferCursor = query.substring(offset, query.length)
        return this.takeWhileNotWhitespace(beforeCursor) + ' ' + terminal + ' ' + this.removeCharactersAfterCursor(atferCursor);
    }

    createOntologyHiearchyFromFile() {
        var ontologyAssertions = this.ontologyAssertionsBuilder.buildOntologyAsertions(new TurtleGraphWrapper(this.ontologyContent));
        var ontologyHiearchy = this.ontologyHiarchyBuilder.createOntologyHiearchy(ontologyAssertions);
        return ontologyHiearchy;
    }

    parseQueryFromFile(queryContent: string) {
        var parser = new ERSParser();
        var result = parser.parse(queryContent);
        return result.query;
    }

    doAutocomplete(queryContent: string) {
        var autocompleteProvider = new OntologyAutocompleteSubProvider(this.ontologyHiearchy);
        var query = this.parseQueryFromFile(queryContent);
        var autocompleteResult = autocompleteProvider.doAutocomplete(query);
        console.log(autocompleteResult);
        return autocompleteResult;
    }

    ontologyAutocompletition(query: string, cursorOffset: number): SparqlAutocompleteItem[] {
        var query = this.injectCursor(query, cursorOffset);
        try {
            var result = this.doAutocomplete(query);
        } catch (e) {
            console.log("Autocomplete broken.");
            return [];
        }
        console.log(query);

        var cursorContext = result.getVariableContext('cursor');
        if (cursorContext != null) {
            return cursorContext.possibleAdvices.map(x => ({
                label: x,
                insertText: '<' + x + '>',
                sortText: "2"
            }));
        }
        return [];

    }

    private supportedKeywords = ["cursor", "base", "prefix", "select", "distinct", "reduced", "as", "construct", "where", "describe", "ask",
        "from", "named", "group", "by", "having", "order", "asc", "desc", "limit", "offset", "values", "load", "silent",
        "into", "clear", "drop", "create", "add", "to", "move", "copy", "insert", "delete", "delete", "with", "delete", "insert",
        "using", "default", "graph", "all", "optional", "service", "bind", "undef", "minus", "union", "filter", "in", "not",
        "bound", "bnode", "concat", "coalesce", "if", "replace", "exists", "separator"];

    keywords(query: string, cursorOffset: number): SparqlAutocompleteItem[] {
        var parser = new ERSParser();
        var query = this.injectUnknown(query, cursorOffset);
        var result = parser.parse(query);
        var errorWithUnknonw = result.tracedParserErrors.filter(x => x.problemToken == "UNKNOWN");
        if (errorWithUnknonw.length == 0) {
            return [{
                label: "nic",
                insertText: "nic"
            }];
        }

        var expectedTokens = errorWithUnknonw[0].expected;

        var currentKeywords: string[] = expectedTokens;
        return currentKeywords.map(x => ({
            label: x,
            insertText: x
        }));
    }

    provideAutocompleteItems(query: string, cursorOffset: number): SparqlAutocompleteItem[] {
        return this.keywords(query, cursorOffset).concat(this.ontologyAutocompletition(query, cursorOffset));
    }
}


