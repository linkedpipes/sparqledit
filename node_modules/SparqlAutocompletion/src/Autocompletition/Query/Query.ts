export enum NodeType {
    Iri,
    Blank,
    Variable,
    Literal
}

export class Node {
    private _originalValue: string;
    private _value: string;
    private _type: NodeType;
    private _range: {
        first_line: number,
        first_column: number,
        last_line: number,
        last_column: number
    } = null;

    public get originalValue() {
        return this._originalValue;
    }

    public get value() {
        return this._value;
    }

    public get type() {
        return this._type;
    }

    constructor(nodeValue: any) {
        if (typeof nodeValue === "string") {
            this.constructorFromString(nodeValue);
        }
        else {
            this.constructorFromObject(nodeValue);
        }
    }

    private constructorFromObject(nodeValue: any) {
        if (nodeValue.type == "var") {
            this._type = NodeType.Variable;
            this._value = nodeValue.name.substring(1, nodeValue.length);
            this._originalValue = nodeValue.name;
            this._range = nodeValue.range;
        } else if (nodeValue.type == "iri") {
            this._type = NodeType.Iri;
            this._value = nodeValue.iri;
            this._originalValue = nodeValue.iri;
            this._range = nodeValue.range;
        }
        else {
            throw new Error();
        }
    }

    private constructorFromString(nodeValue: string) {
        this._originalValue = nodeValue;
        // TODO test the method especially substring
        var startChar = nodeValue.substr(0, 1);
        if (startChar === "?" || startChar === "$") {
            //variable
            this._type = NodeType.Variable;
            this._value = nodeValue.substring(1, nodeValue.length);
        } else if (startChar === "\"") {
            //literal
            this._type = NodeType.Literal;
            this._value = nodeValue;
        } else if (nodeValue.substr(0, 2) === "_:") {
            // blank node
            this._type = NodeType.Blank;
            this._value = nodeValue.substring(2, nodeValue.length);
        } else {
            // iri 
            this._type = NodeType.Iri;
            this._value = nodeValue;
        }
    }
}

export class Triple {
    public subject: Node;
    public predicate: Node;
    public object: Node;

    constructor(subject: string,
        predicate: string,
        object: string) {

        this.subject = new Node(subject);
        this.predicate = new Node(predicate);
        this.object = new Node(object);
    }

    getAllNodes() {
        return [this.subject, this.predicate, this.object];
    }
}

export class Block {
    public triples: Triple[];

    constructor(queryBlock: any) {
        this.triples = queryBlock.map((x: any) =>
            new Triple(x.subject,
                x.predicate,
                x.object)
        );
    }

    matchNode(node: Node, value: string) {
        if (value == null) {
            return true;
        }

        return node.originalValue == value;
    }

    match(subject: string, predicate: string, object: string) {
        var result = this.triples.filter(x => {
            return this.matchNode(x.subject, subject) &&
                this.matchNode(x.predicate, predicate) &&
                this.matchNode(x.object, object);
        });
        return result;
    }
}