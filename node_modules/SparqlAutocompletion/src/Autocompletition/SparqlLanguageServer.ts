import { Block } from './Query/Query';
import { injectCursor } from './Utils/QueryTerminalInjection';
import { QueryClassInferencer } from './Inference/QueryClassInferencer';
import { QueryAdviceInferencer } from './Inference/QueryAdviceInferencer';
import { OntologyAssertions } from '../Ontology/OntologyAssertions';
import { TurtleGraphWrapper } from '../GraphTools/TurtleGraphWrapper';
import { OntologyHiearchy } from '../Ontology/OntologyHierchy';
import { OntologyHiearchyBuilder } from '../Ontology/Algorithms/OntologyHiearchyBuilder';
import { OntologyAssertionsBuilder } from '../Ontology/Algorithms/OntologyAssertionBuilder';
import { SparqlAutocompleteItem, SparqlAutocompleteProvider } from './SparqlAutocompleteProvider';
import { SparqlSignatureHelpProvider } from './SparqlSignatureHelpProvider';
import { Node } from '../Autocompletition/Query/Query'
import * as _ from 'lodash';
import { ERSParser } from 'ERSParser';

export class SparqlLanguageServer {

    public _ontologyHiearchy: OntologyHiearchy;
    public _sparqlAutocompleteProvider: SparqlAutocompleteProvider;
    public _sparqlSignatureHelpProvider: SparqlSignatureHelpProvider;

    constructor(private ontologyAssertions: OntologyAssertions) {
        var ontologyHiarchyBuilder = new OntologyHiearchyBuilder();
        this._ontologyHiearchy = ontologyHiarchyBuilder.createOntologyHiearchy(ontologyAssertions);
        this._sparqlAutocompleteProvider = new SparqlAutocompleteProvider(this._ontologyHiearchy);
        this._sparqlSignatureHelpProvider = new SparqlSignatureHelpProvider(this._ontologyHiearchy);
    }

    public get ontologyHiearchy() {
        return this._ontologyHiearchy;
    }

    public get sparqlSignatureHelpProvider() {
        return this._sparqlSignatureHelpProvider;
    }

    provideAutocompleteItems(query: string, cursorOffset: number): SparqlAutocompleteItem[] {
        console.log("Provide items");
        return this._sparqlAutocompleteProvider.provideAutocompleteItems(query, cursorOffset);
    }

    findHover(nodes: Node[], cursorOffset: number) {

    }

    yylocToOffset(text: string, line: number, column: number) {
        var lines = text.split('\n');
        return _(lines).take(line - 1).map(x => x.length + 1).sum() + column;
    }

    provideHover(query: string, cursorOffset: number) {
        var queryInferencer = new QueryAdviceInferencer(this.ontologyHiearchy);

        var parser = new ERSParser();
        var parsedQuery = parser.parse(query).query;
        if(parsedQuery == null){
            return null;
        }
        var block = new Block(parsedQuery.where[0].triples);
        console.log(block);
        var queryNodes = _(block.triples)
            .map(x => [x.object, x.predicate, x.subject])
            .flatten<Node>()
            .filter(node => (<any>node)._range != null)
            .map(node => ({
                value: node,
                from: this.yylocToOffset(query, (<any>node)._range.first_line, (<any>node)._range.first_column),
                to: this.yylocToOffset(query, (<any>node)._range.last_line, (<any>node)._range.last_column)
            }));

        var winnerNode = queryNodes
            .filter(node => node.from <= cursorOffset && cursorOffset <= node.to)
            .first();

        console.log(cursorOffset);
        console.log(winnerNode);
        if (winnerNode == null) {
            return null;
        }

        return {
            contents: [winnerNode.value.originalValue],
            range: {
                startLineNumber: (<any>winnerNode.value)._range.first_line,
                startColumn: (<any>winnerNode.value)._range.first_column + 1,
                endLineNumber: (<any>winnerNode.value)._range.last_line,
                endColumn: (<any>winnerNode.value)._range.last_column + 1,
            }
        };
    }
}