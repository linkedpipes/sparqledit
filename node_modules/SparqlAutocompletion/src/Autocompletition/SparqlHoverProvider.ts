import { SparqlSignatureHelp } from './SparqlSignatureHelpProvider';
import { QueryClassInferencer } from './Inference/QueryClassInferencer';
import { OntologyHiearchy } from '../Ontology/OntologyHierchy';
import { NodeType, Block, Node } from './Query/Query';
import * as _ from 'lodash';
import { ERSParser } from 'ERSParser';

export class SparqlHoverProvider {
    private queryInferencer: QueryClassInferencer;

    constructor(private ontologyHiearchy: OntologyHiearchy) {
        this.queryInferencer = new QueryClassInferencer(this.ontologyHiearchy);
    }

    yylocToOffset(text: string, line: number, column: number) {
        var lines = text.split('\n');
        return _(lines).take(line - 1).map(x => x.length + 1).sum() + column;
    }

    getInfoForNode(query: any, node: Node) {
        if (node.type == NodeType.Variable) {
            var classInferenceResult = this.queryInferencer.inferClasses(query);
            var nodeInformations = classInferenceResult.getVariable(node.value);
            if (nodeInformations == null) {
                return null;
            }
            return nodeInformations.possibleClasses.map(x => x.getText());
        } else if (node.type == NodeType.Iri) {
            return [node.value];
        }
    }

    provideHover(query: string, cursorOffset: number) {
        var parser = new ERSParser();
        var parsedQuery = parser.parse(query).query;
        if (parsedQuery == null) {
            return null;
        }
        var block = new Block(parsedQuery.where[0].triples);
        var queryNodes = _(block.triples)
            .map(x => [x.object, x.predicate, x.subject])
            .flatten<Node>()
            .filter(node => (<any>node)._range != null)
            .map(node => ({
                value: node,
                from: this.yylocToOffset(query, (<any>node)._range.first_line, (<any>node)._range.first_column),
                to: this.yylocToOffset(query, (<any>node)._range.last_line, (<any>node)._range.last_column)
            }));

        var winnerNode = queryNodes
            .filter(node => node.from <= cursorOffset && cursorOffset <= node.to)
            .first();

        if (winnerNode == null) {
            return null;
        }

        var hoverContent = this.getInfoForNode(parsedQuery, winnerNode.value);
        return {
            contents: hoverContent,
            range: {
                startLineNumber: (<any>winnerNode.value)._range.first_line,
                startColumn: (<any>winnerNode.value)._range.first_column + 1,
                endLineNumber: (<any>winnerNode.value)._range.last_line,
                endColumn: (<any>winnerNode.value)._range.last_column + 1,
            }
        };
    }
}