import { OntologyAssertions } from '../Ontology/OntologyAssertions';
import { AtomicClass } from '../Ontology/OntologyClass';
import { SparqlSignatureHelp } from './SparqlSignatureHelpProvider';
import { QueryClassInferencer } from './Inference/QueryClassInferencer';
import { OntologyHiearchy } from '../Ontology/OntologyHierchy';
import { NodeType, Block, Node } from './Query/Query';
import { TriplesExplorer } from '../Autocompletition/Inference/TriplesExplorer';

import * as _ from 'lodash';
import { ERSParser } from 'ERSParser';

export class SparqlHoverProvider {
    private queryInferencer: QueryClassInferencer;
    private tripleExplorer: TriplesExplorer = new TriplesExplorer();

    constructor(private ontologyHiearchy: OntologyHiearchy, private languageTag: string) {
        this.queryInferencer = new QueryClassInferencer(this.ontologyHiearchy);
    }

    yylocToOffset(text: string, line: number, column: number) {
        var lines = text.split('\n');
        return _(lines).take(line - 1).map(x => x.length + 1).sum() + column;
    }

    getInfoForNode(assertions: OntologyAssertions, query: any, node: Node) {
        if (node.type == NodeType.Variable) {
            var classInferenceResult = this.queryInferencer.inferClasses(query);
            var nodeInformations = classInferenceResult.getVariable(node.value);
            if (nodeInformations == null) {
                return null;
            }

            return nodeInformations.possibleClasses.map(x => x.label.getLabelByLanguage(this.languageTag) || "null");
        } else if (node.type == NodeType.Iri) {
            var propertyInformations = assertions.findPropertyByName(node.originalValue);
            if (propertyInformations == null) {
                return null;
            }
            return [propertyInformations.label.getLabelByLanguage(this.languageTag) || "nullaa"];
        }
    }

    provideHover(query: string, cursorOffset: number) {
        var parser = new ERSParser();
        var parsedQuery = parser.parse(query).query;
        if (parsedQuery == null) {
            return null;
        }
        var triples = this.tripleExplorer.findTriples(parsedQuery);
        var queryNodes = _(triples)
            .map(x => [x.object, x.predicate, x.subject])
            .flatten<Node>()
            .filter(node => (<any>node)._range != null)
            .map(node => ({
                value: node,
                from: this.yylocToOffset(query, (<any>node)._range.first_line, (<any>node)._range.first_column),
                to: this.yylocToOffset(query, (<any>node)._range.last_line, (<any>node)._range.last_column)
            }));

        var winnerNode = queryNodes
            .filter(node => node.from <= cursorOffset && cursorOffset <= node.to)
            .first();


        if (winnerNode == null) {
            return null;
        }
        var assertions = this.ontologyHiearchy.ontologyAssertions;
        var hoverContent = this.getInfoForNode(assertions, parsedQuery, winnerNode.value);
        return {
            contents: hoverContent,
            range: {
                startLineNumber: (<any>winnerNode.value)._range.first_line,
                startColumn: (<any>winnerNode.value)._range.first_column + 1,
                endLineNumber: (<any>winnerNode.value)._range.last_line,
                endColumn: (<any>winnerNode.value)._range.last_column + 1,
            }
        };
    }
}