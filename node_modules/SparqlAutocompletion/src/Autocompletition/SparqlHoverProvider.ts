import { OntologyAssertions } from '../Ontology/OntologyAssertions';
import { AtomicClass } from '../Ontology/OntologyClass';
import { SparqlSignatureHelp } from './SparqlSignatureHelpProvider';
import { QueryClassInferencer } from './Inference/QueryClassInferencer';
import { OntologyHierarchy } from '../Ontology/OntologyHierarchy';
import { NodeType, Block, Node } from './Query/Query';
import { TriplesExplorer } from '../Autocompletition/Inference/TriplesExplorer';

import * as _ from 'lodash';
import { ERSParser } from 'ERSParser';
import { OntologyLabel } from 'SparqlAutocompletion/src/Ontology/OntologyLabel';
import { CleanOntologyClassTextFormatter } from '../Ontology/OntologyClassTextFormatter';

export class SparqlHoverProvider {
    private queryInferencer: QueryClassInferencer;
    private tripleExplorer: TriplesExplorer = new TriplesExplorer();
    private ontologyClassTextFormatter: CleanOntologyClassTextFormatter = new CleanOntologyClassTextFormatter();

    constructor(private ontologyHierarchy: OntologyHierarchy, private languageTag: string) {
        this.queryInferencer = new QueryClassInferencer(this.ontologyHierarchy);
    }

    yylocToOffset(text: string, line: number, column: number) {
        var lines = text.split('\n');
        return _(lines).take(line - 1).map(x => x.length + 1).sum() + column;
    }

    createLabelLine(label: OntologyLabel) {
        if (label == null) {
            return "";
        }
        var labelLanguageContent = label.getLabelByLanguage(this.languageTag);
        if (labelLanguageContent == null) {
            return "";
        }
        return `Label: "${labelLanguageContent}"`;
    }

    getInfoForNode(assertions: OntologyAssertions, query: any, node: Node) {
        // TODO: extract
        if (node.type == NodeType.Variable) {
            var classInferenceResult = this.queryInferencer.inferClasses(query);
            var nodeInformations = classInferenceResult.getVariable(node.value);
            if (nodeInformations == null) {
                return null;
            }

            var result = nodeInformations.possibleClasses
                .map(possibleClass =>
                    `${possibleClass.getText(this.ontologyClassTextFormatter)} \n\n`
                    + this.createLabelLine(possibleClass.label));

            return result;
        } else if (node.type == NodeType.Iri) {
            var possibleProperty = assertions.findPropertyByName(node.originalValue);
            if (possibleProperty != null) {
                return [this.createLabelLine(possibleProperty.label)];
            }

            var possibleClass = assertions.findClassByIri(node.originalValue);
            if (possibleClass != null) {
                return [this.createLabelLine(possibleClass.label)];
            }

            return null;
        }
    }

    provideHover(query: string, cursorOffset: number) {
        var parser = new ERSParser();
        var parsedQuery = parser.parse(query).query;
        if (parsedQuery == null) {
            return null;
        }
        var triples = this.tripleExplorer.findTriples(parsedQuery);
        var queryNodes = _(triples)
            .map(x => [x.object, x.predicate, x.subject])
            .flatten<Node>()
            .filter(node => (<any>node)._range != null)
            .map(node => ({
                value: node,
                from: this.yylocToOffset(query, (<any>node)._range.first_line, (<any>node)._range.first_column),
                to: this.yylocToOffset(query, (<any>node)._range.last_line, (<any>node)._range.last_column)
            }));

        var winnerNode = queryNodes
            .filter(node => node.from <= cursorOffset && cursorOffset <= node.to)
            .first();


        if (winnerNode == null) {
            return null;
        }
        var assertions = this.ontologyHierarchy.ontologyAssertions;
        var hoverContent = this.getInfoForNode(assertions, parsedQuery, winnerNode.value);
        return {
            contents: hoverContent,
            range: {
                startLineNumber: (<any>winnerNode.value)._range.first_line,
                startColumn: (<any>winnerNode.value)._range.first_column + 1,
                endLineNumber: (<any>winnerNode.value)._range.last_line,
                endColumn: (<any>winnerNode.value)._range.last_column + 1,
            }
        };
    }
}