import { AtomicClass } from '../../Ontology/OntologyClass';
import { OntologyConcept } from "../../Ontology/OntologyConcept";
import { OntologyAssertions } from '../../Ontology/OntologyAssertions';
import { injectCursor } from '../Utils/QueryTerminalInjection';
import { ERSParser } from "ERSParser";
import { QueryClassInferencer, InferenceVariable } from "../Inference/QueryClassInferencer";
import { QueryClassInferencerResult } from "./QueryClassInferencer";
import { IParentOntologyClassTracker, createParentOntologyTrackerFromSettings } from './ParentOntologyClassTracker';
import { ILogger } from '../../Logging/Logger';
import { StringDictionary } from '../../Collections/Dictionary';
import { addExtractedClass } from './AtomicClassExtraction';
import { IQueryAdvice, PropertyQueryAdvice, RdfTypeQueryAdvice } from './QueryAdvice';
import { createPropertyAdviceForOntologyClass } from "./PropertyAdviceHelper";

import * as _ from 'lodash';

export function bubbleOntologyConcept(ontologyConcepts: OntologyConcept[], ontologyConcept: OntologyConcept) {
    var classes = ontologyConcept.ontologyClasses;
    for (var montologyConcept of ontologyConcepts) {
        if (_.some(montologyConcept.ontologyClasses, x => _.some(classes, y => x.getText() == y.getText()))) {
            classes
                .filter(x => _.every(montologyConcept.ontologyClasses, y => x.getText() != y.getText()))
                .forEach(x => montologyConcept.ontologyClasses.push(x))
            return;
        }
    }
    ontologyConcepts.push(ontologyConcept);
}

export function mergePossibleClassOntologyConcepts(possibleClassOntologyConcepts: OntologyConcept[]): OntologyConcept[] {
    if (possibleClassOntologyConcepts.length == 0) {
        return [];
    }
    var ontologyConceptAccumulator = [possibleClassOntologyConcepts[0]];
    var restOntologyConcepts = possibleClassOntologyConcepts.slice(1);

    for (var ontologyConcept of restOntologyConcepts) {
        bubbleOntologyConcept(ontologyConceptAccumulator, ontologyConcept);
    }

    return ontologyConceptAccumulator;
}

export class QueryAdviceInferencer {
    private tracker: IParentOntologyClassTracker;

    private classInferencer: QueryClassInferencer;

    constructor(
        private logger: ILogger,
        private ontologyAssertions: OntologyAssertions,
        private adviseAtomicClassFromComplexClass: boolean,
        propertySelectorType: "Restricted" | "Full") {

        this.tracker = createParentOntologyTrackerFromSettings(propertySelectorType);
        this.classInferencer = new QueryClassInferencer(this.ontologyAssertions);
    }

    private getAdvicesForVariable(
        context: QueryClassInferencerResult,
        inferenceVariable: InferenceVariable,
        prefixes: StringDictionary<string>): IQueryAdvice {

        if (inferenceVariable.isRdfTypeObject) {
            var allAtomicClasses = this.ontologyAssertions.classes
                .filter(x => (x instanceof AtomicClass))
                .map(x => (<AtomicClass>x).iri);

            return new RdfTypeQueryAdvice(allAtomicClasses);
        }

        if (inferenceVariable.subjectVariableName == null) {
            return null;
        }

        var inferenceVariable = context.getVariable(inferenceVariable.subjectVariableName)

        if (inferenceVariable == null || inferenceVariable.possibleClasses.length == 0) {
            return null;
        }

        var possibleClasses = this.adviseAtomicClassFromComplexClass ? addExtractedClass(inferenceVariable.possibleClasses) : inferenceVariable.possibleClasses;
        var possibleClassOntologyConcepts = _(possibleClasses)
            .map(x => createPropertyAdviceForOntologyClass(this.tracker, this.ontologyAssertions, x))
            .flatten<OntologyConcept>()
            .value();

        var ontologyConcepts = mergePossibleClassOntologyConcepts(possibleClassOntologyConcepts);
        return new PropertyQueryAdvice(ontologyConcepts, this.ontologyAssertions, prefixes);
    }

    inferVariableAdvices(query: any, variableName: string): IQueryAdvice {
        var context = this.classInferencer.inferClasses(query);

        var inferenceVariable = context.getVariable(variableName);
        if (inferenceVariable == null) {
            return null;
        }

        var result = this.getAdvicesForVariable(context, inferenceVariable, query.prefixes);
        return result;
    }

    providePropertyAutocompletion(queryContent: string, cursorOffset: number) {
        try {
            var queryWithCursor = injectCursor(queryContent, cursorOffset);
            var parser = new ERSParser();
            return this.inferVariableAdvices(parser.parse(queryWithCursor).query, 'cursor');
        } catch (e) {
            this.logger.log(e);
            return null;
        }
    }
}