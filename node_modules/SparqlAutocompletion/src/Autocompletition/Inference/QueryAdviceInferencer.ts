import { IOntologyClass, AtomicClass } from '../../Ontology/OntologyClass';
import { OntologyConcept, OntologyHiearchy } from '../../Ontology/OntologyHierchy';
import { OntologyProperty } from '../../Ontology/OntologyAssertions';
import { RestrictedPropertySelector } from '../PropertySelector/RestrictedPropertySelector';
import { Block, Node, NodeType } from '../Query/Query';
import { RdfIri } from '../../Utils/RdfIri';
import { injectCursor } from '../Utils/QueryTerminalInjection';
import { ERSParser } from "ERSParser";
import { QueryClassInferencer, VariableItem } from "SparqlAutocompletion/src/Autocompletition/Inference/QueryClassInferencer";
import { QueryClassInferencerResult } from "./QueryClassInferencer";

import * as _ from 'lodash';

var escapeStringRegexp = require('escape-string-regexp');

export class VariableAdvices {
    public possibleClasses: IOntologyClass[] = [];
    public possibleAdvices: string[] = [];
    public possibleAdvicesStructured: { concept: OntologyConcept, properties: OntologyProperty[] }[]

    constructor(public name: string) {

    }
}

export class QueryAdviceInferencer {
    // private getAllProps: GetAllProps;
    private getAllProps: RestrictedPropertySelector;
    
    private classInferencer: QueryClassInferencer;

    constructor(private ontologyHiearchy: OntologyHiearchy) {
        this.getAllProps = new RestrictedPropertySelector(ontologyHiearchy);
        // this.getAllProps = new GetAllProps(ontologyHiearchy);

        this.classInferencer = new QueryClassInferencer(this.ontologyHiearchy);
    }

    private processPrefixesInIri(prefixes: { [key: string]: string }, advices: string[]): string[] {
        if (!prefixes) {
            return advices;
        }

        return advices.map(iri => {
            for (var prefix in prefixes) {
                var prefixValue = prefixes[prefix];
                iri = iri.replace(new RegExp("^" + escapeStringRegexp(prefixValue)), prefix + ":");
            }
            return iri;
        });
    }

    getAdvicesForClass(ontologyClass: IOntologyClass, prefixes: { [key: string]: string }) {
        var computedProps = this.getAllProps.doAlgorithm(ontologyClass);

        var chucked = computedProps.getPropertiesByChunk();

        var ress = _(chucked).map(x => ({
            name: x.concept
                .ontologyClasses
                .map(x => x.getText()).join(','),
            props: x.properties
        })).map(x => x.props.map(y => x.name + '  ' + y.name))
            .flatten<string>()
            .value();

        var newAdvices = computedProps.getAllPoperties().map(x => x.name);
        newAdvices = this.processPrefixesInIri(prefixes, newAdvices);
        return {
            advices: newAdvices,
            advicesStructered: chucked
        };
    }

    getAdvicesForVariable(context: QueryClassInferencerResult, variableItem: VariableItem, prefixes: { [key: string]: string }) {

        if (variableItem.isRdfTypeObject) {
            var allAtomicClasses = this.ontologyHiearchy.ontologyAssertions.classes
                .filter(x => (x instanceof AtomicClass))
                .map(x => (<AtomicClass>x).iri);

            return {
                advices: allAtomicClasses,
                advicesStructered: null
            };

        }

        var subjectVariable = variableItem.subjectVariableName;
        if (variableItem.subjectVariableName != null) {
            var subjectVariableItem = context.getVariable(variableItem.subjectVariableName)
            if (subjectVariableItem.possibleClasses.length > 0) {
                return this.getAdvicesForClass(context.getVariable(variableItem.subjectVariableName).possibleClasses[0], prefixes);
            }
        }
        return {
            advices: [],
            advicesStructered: null
        }
    }

    createVariableAdvices(context: QueryClassInferencerResult, variableItem: VariableItem, prefixes: { [key: string]: string }): VariableAdvices {
        var resultVariableItem = new VariableAdvices(variableItem.name);
        resultVariableItem.possibleClasses = variableItem.possibleClasses;

        var advices = this.getAdvicesForVariable(context, variableItem, prefixes);

        resultVariableItem.possibleAdvices = advices.advices;
        resultVariableItem.possibleAdvicesStructured = advices.advicesStructered;
        return resultVariableItem;
    }

    inferVariableAdvices(query: any, variableName: string): VariableAdvices {
        var context = this.classInferencer.inferClasses(query);
        
        var variableItem = context.getVariable(variableName);
        if (variableItem == null) {
            return null;
        }

        var result = this.createVariableAdvices(context, variableItem, query.prefixes);
        return result;
    }

    providePropertyAutocompletion(queryContent: string, cursorOffset: number) {
        try {
            var queryWithCursor = injectCursor(queryContent, cursorOffset);
            var parser = new ERSParser();
            var cursorContext = this.inferVariableAdvices(parser.parse(queryWithCursor).query, 'cursor');
        } catch (e) {
            console.log(e);
            return null;
        }

        if (cursorContext == null) {
            return null;
        }

        return cursorContext.possibleAdvicesStructured;
    }

}