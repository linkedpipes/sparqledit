import { IOntologyClass, AtomicClass } from '../../Ontology/OntologyClass';
import { OntologyConcept, OntologyHiearchy } from '../../Ontology/OntologyHierchy';
import { OntologyProperty } from '../../Ontology/OntologyAssertions';
import { RestrictedPropertySelector } from '../PropertySelector/RestrictedPropertySelector';
import { Block, Node, NodeType } from '../Query/Query';
import { RdfIri } from '../../Utils/RdfIri';
import { injectCursor } from '../Utils/QueryTerminalInjection';
import { ERSParser } from "ERSParser";
import { QueryClassInferencer, VariableItem } from "../Inference/QueryClassInferencer";
import { QueryClassInferencerResult } from "./QueryClassInferencer";
import { IPropertySelector } from '../PropertySelector/IPropertySelector';
import { PropertySelectorFactory } from '../PropertySelector/PropertySelectorFactory';
import { PrefixProcessor } from '../Query/PrefixProcessor';

import * as _ from 'lodash';

export interface IQueryAdvice {
    getStringQueryAdvices(): string[]
}

export class RdfTypeQueryAdvice implements IQueryAdvice {
    constructor(private possibleRdfTypes: string[]) {

    }

    getStringQueryAdvices(): string[] {
        return this.possibleRdfTypes;
    }

    getData() {
        return this.possibleRdfTypes;
    }
}

export class PropertyQeuryAdvice implements IQueryAdvice {
    constructor(private data: { concept: OntologyConcept, properties: OntologyProperty[] }[]) {

    }

    getStringQueryAdvices(): string[] {
        var result = _(this.data)
            .map(x => x.properties.map(y => y.name))
            .flatten<string>()
            .value();

        return result;
    }

    getData(): { concept: OntologyConcept, properties: OntologyProperty[] }[] {
        return this.data;
    }
}

export class VariableAdvices {
    public possibleClasses: IOntologyClass[] = [];

    constructor(public name: string,
        public possibleAdvicesStructured: IQueryAdvice,
        private prefixProcessor: PrefixProcessor) {

    }

    public getPossibleAdvices(): string[] {
        var result = _(this.possibleAdvicesStructured.getStringQueryAdvices())
            .map(propertyName => this.prefixProcessor.processPrefixesInIri(propertyName))
            .value();

        return result;
    }
}

export class QueryAdviceInferencer {
    private propertySelector: IPropertySelector;

    private classInferencer: QueryClassInferencer;

    constructor(propertySelectorType: "Restricted" | "Full", private ontologyHiearchy: OntologyHiearchy) {
        var propertySelectorFactory = new PropertySelectorFactory();

        this.propertySelector = propertySelectorFactory.createPropertySelector("Full", ontologyHiearchy);

        this.classInferencer = new QueryClassInferencer(this.ontologyHiearchy);
    }

    getPropertyAdvicesForClass(ontologyClass: IOntologyClass) {
        var propertiesProvider = this.propertySelector.getPropertiesFor(ontologyClass);
        var chunkedProperties = propertiesProvider.getPropertiesByChunk();
        return chunkedProperties;
    }

    getAdvicesForVariable(
        context: QueryClassInferencerResult,
        variableItem: VariableItem,
        prefixes: { [key: string]: string }): IQueryAdvice {

        if (variableItem.isRdfTypeObject) {
            var allAtomicClasses = this.ontologyHiearchy.ontologyAssertions.classes
                .filter(x => (x instanceof AtomicClass))
                .map(x => (<AtomicClass>x).iri);

            return new RdfTypeQueryAdvice(allAtomicClasses);
        }

        var subjectVariable = variableItem.subjectVariableName;
        if (variableItem.subjectVariableName != null) {
            var subjectVariableItem = context.getVariable(variableItem.subjectVariableName)
            if (subjectVariableItem.possibleClasses.length > 0) {
                var structuredAdvices = this.getPropertyAdvicesForClass(context.getVariable(variableItem.subjectVariableName).possibleClasses[0]);
                return new PropertyQeuryAdvice(structuredAdvices);
            }
        }
        return null;
    }

    createVariableAdvices(context: QueryClassInferencerResult, variableItem: VariableItem, prefixes: { [key: string]: string }): VariableAdvices {
        var advices = this.getAdvicesForVariable(context, variableItem, prefixes);
        var resultVariableItem = new VariableAdvices(variableItem.name,
            advices,
            new PrefixProcessor(prefixes));
        resultVariableItem.possibleClasses = variableItem.possibleClasses;

        return resultVariableItem;
    }

    inferVariableAdvices(query: any, variableName: string): VariableAdvices {
        var context = this.classInferencer.inferClasses(query);

        var variableItem = context.getVariable(variableName);
        if (variableItem == null) {
            return null;
        }

        var result = this.createVariableAdvices(context, variableItem, query.prefixes);
        return result;
    }

    providePropertyAutocompletion(queryContent: string, cursorOffset: number) {
        try {
            var queryWithCursor = injectCursor(queryContent, cursorOffset);
            var parser = new ERSParser();
            var cursorContext = this.inferVariableAdvices(parser.parse(queryWithCursor).query, 'cursor');
        } catch (e) {
            console.log(e);
            return null;
        }

        if (cursorContext == null) {
            return null;
        }

        return cursorContext.possibleAdvicesStructured;
    }

}