import { IOntologyClass, AtomicClass } from '../../Ontology/OntologyClass';
import { OntologyConcept } from "../../Ontology/OntologyConcept";
import { OntologyProperty, OntologyAssertions } from '../../Ontology/OntologyAssertions';
import { injectCursor } from '../Utils/QueryTerminalInjection';
import { ERSParser } from "ERSParser";
import { QueryClassInferencer, InferenceVariable } from "../Inference/QueryClassInferencer";
import { QueryClassInferencerResult } from "./QueryClassInferencer";
import { IPropertySelector } from '../PropertySelector/IPropertySelector';
import { PropertySelectorFactory } from '../PropertySelector/PropertySelectorFactory';
import { PrefixProcessor } from '../Query/PrefixProcessor';
import { ILogger } from '../../Logging/Logger';
import { StringDictionary } from '../../Collections/Dictionary';

import * as _ from 'lodash';

export interface IQueryAdvice {
    getStringQueryAdvices(): string[]
}

export class RdfTypeQueryAdvice implements IQueryAdvice {
    constructor(private possibleRdfTypes: string[]) {

    }

    getStringQueryAdvices(): string[] {
        return this.possibleRdfTypes;
    }

    getData() {
        return this.possibleRdfTypes;
    }
}

export class PropertyQueryAdvice implements IQueryAdvice {

    public processor: PrefixProcessor;

    private ontologyAssertions: OntologyAssertions;

    constructor(
        public orderConcepts: OntologyConcept[],
        ontologyAssertions: OntologyAssertions,
        prefixes: StringDictionary<string>) {

        this.ontologyAssertions = ontologyAssertions;
        this.processor = new PrefixProcessor(prefixes);
    }

    getAllPoperties() {
        var result = _(this.orderConcepts)
            .map(x => this.getPropertiesOfConcept(x))
            .flatten<OntologyProperty>()
            .value();
        return result;
    }

    getPropertiesOfClass(ontologyClass: IOntologyClass) {
        return this.ontologyAssertions.findPropertiesByDomain(ontologyClass);
    }

    getPropertiesOfConcept(ontologyConcept: OntologyConcept) {
        var result = _(ontologyConcept.ontologyClasses)
            .map(x => this.getPropertiesOfClass(x))
            .flatten<OntologyProperty>()
            .value();

        return result;
    }

    getPropertiesByChunk() {
        return this.orderConcepts.map(x => ({ concept: x, properties: this.getPropertiesOfConcept(x) }))
    }

    getStringQueryAdvices(): string[] {
        var result = _(this.getPropertiesByChunk())
            .map(x => x.properties.map(y => this.processor.processPrefixesInIri(y.name)))
            .flatten<string>()
            .value();

        return result;
    }

    getData(): { concept: OntologyConcept, properties: OntologyProperty[] }[] {
        return this.getPropertiesByChunk();
    }
}

export function bubbleOntologyConcept(ontologyConcepts: OntologyConcept[], ontologyConcept: OntologyConcept) {
    var classes = ontologyConcept.ontologyClasses;
    for (var montologyConcept of ontologyConcepts) {
        // TODO: equality
        if (_.some(montologyConcept.ontologyClasses, x => _.some(classes, y => x.getText() == y.getText()))) {
            // merge concepts together 
            classes
                .filter(x => _.every(montologyConcept.ontologyClasses, y => x.getText() != y.getText()))
                .forEach(x => montologyConcept.ontologyClasses.push(x))
            return;
        }
    }
    ontologyConcepts.push(ontologyConcept);
}

export class QueryAdviceInferencer {
    private propertySelector: IPropertySelector;

    private classInferencer: QueryClassInferencer;

    constructor(
        private logger: ILogger,
        private ontologyAssertions: OntologyAssertions,
        propertySelectorType: "Restricted" | "Full") {

        var propertySelectorFactory = new PropertySelectorFactory();

        this.propertySelector = propertySelectorFactory.createPropertySelector(propertySelectorType, ontologyAssertions);

        this.classInferencer = new QueryClassInferencer(this.ontologyAssertions);
    }

    private mergePossibleClassOntologyConcepts(possibleClassOntologyConcepts: OntologyConcept[][]): OntologyConcept[] {
        var ontologyConcepts = possibleClassOntologyConcepts[0];
        var restOntologyConcepts = _(possibleClassOntologyConcepts)
            .slice(1)
            .flatten<OntologyConcept>()
            .value();

        for (var ontologyConcept of restOntologyConcepts) {
            bubbleOntologyConcept(ontologyConcepts, ontologyConcept);
        }

        return ontologyConcepts;
    }

    private getAdvicesForVariable(
        context: QueryClassInferencerResult,
        inferenceVariable: InferenceVariable,
        prefixes: StringDictionary<string>): IQueryAdvice {

        if (inferenceVariable.isRdfTypeObject) {
            var allAtomicClasses = this.ontologyAssertions.classes
                .filter(x => (x instanceof AtomicClass))
                .map(x => (<AtomicClass>x).iri);

            return new RdfTypeQueryAdvice(allAtomicClasses);
        }

        if (inferenceVariable.subjectVariableName == null) {
            return null;
        }

        var inferenceVariable = context.getVariable(inferenceVariable.subjectVariableName)

        if (inferenceVariable == null || inferenceVariable.possibleClasses.length == 0) {
            return null;
        }
        var possibleClassOntologyConcepts = inferenceVariable.possibleClasses.map(x => this.propertySelector.getPropertiesFor(x));
        var ontologyConcepts = this.mergePossibleClassOntologyConcepts(possibleClassOntologyConcepts);
        return new PropertyQueryAdvice(ontologyConcepts, this.ontologyAssertions, prefixes);
    }

    inferVariableAdvices(query: any, variableName: string): IQueryAdvice {
        var context = this.classInferencer.inferClasses(query);

        var inferenceVariable = context.getVariable(variableName);
        if (inferenceVariable == null) {
            return null;
        }

        var result = this.getAdvicesForVariable(context, inferenceVariable, query.prefixes);
        return result;
    }

    providePropertyAutocompletion(queryContent: string, cursorOffset: number) {
        try {
            var queryWithCursor = injectCursor(queryContent, cursorOffset);
            var parser = new ERSParser();
            return this.inferVariableAdvices(parser.parse(queryWithCursor).query, 'cursor');
        } catch (e) {
            this.logger.log(e);
            return null;
        }
    }
}