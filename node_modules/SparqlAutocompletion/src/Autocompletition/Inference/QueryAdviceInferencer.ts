import { IOntologyClass, AtomicClass } from '../../Ontology/OntologyClass';
import { OntologyConcept, OntologyHierarchy } from '../../Ontology/OntologyHierarchy';
import { OntologyProperty } from '../../Ontology/OntologyAssertions';
import { RestrictedPropertySelector } from '../PropertySelector/RestrictedPropertySelector';
import { Block, Node, NodeType } from '../Query/Query';
import { RdfIri } from '../../Utils/RdfIri';
import { injectCursor } from '../Utils/QueryTerminalInjection';
import { ERSParser } from "ERSParser";
import { QueryClassInferencer, InferenceVariable } from "../Inference/QueryClassInferencer";
import { QueryClassInferencerResult } from "./QueryClassInferencer";
import { IPropertySelector } from '../PropertySelector/IPropertySelector';
import { PropertySelectorFactory } from '../PropertySelector/PropertySelectorFactory';
import { PrefixProcessor } from '../Query/PrefixProcessor';
import { ILogger } from '../../Logging/Logger';

import * as _ from 'lodash';

export interface IQueryAdvice {
    getStringQueryAdvices(): string[]
}

export class RdfTypeQueryAdvice implements IQueryAdvice {
    constructor(private possibleRdfTypes: string[]) {

    }

    getStringQueryAdvices(): string[] {
        return this.possibleRdfTypes;
    }

    getData() {
        return this.possibleRdfTypes;
    }
}

export class PropertyQueryAdvice implements IQueryAdvice {

    public processor: PrefixProcessor;

    constructor(public possibleClasses: IOntologyClass[], private data: { concept: OntologyConcept, properties: OntologyProperty[] }[],
        prefixes: { [key: string]: string }) {
        this.processor = new PrefixProcessor(prefixes);
    }

    getStringQueryAdvices(): string[] {
        var result = _(this.data)
            .map(x => x.properties.map(y => this.processor.processPrefixesInIri(y.name)))
            .flatten<string>()
            .value();

        return result;
    }

    getData(): { concept: OntologyConcept, properties: OntologyProperty[] }[] {
        return this.data;
    }
}

export class QueryAdviceInferencer {
    private propertySelector: IPropertySelector;

    private classInferencer: QueryClassInferencer;

    constructor(
        private logger: ILogger,
        private ontologyHierarchy: OntologyHierarchy,
        propertySelectorType: "Restricted" | "Full") {

        var propertySelectorFactory = new PropertySelectorFactory();

        this.propertySelector = propertySelectorFactory.createPropertySelector("Full", ontologyHierarchy);

        this.classInferencer = new QueryClassInferencer(this.ontologyHierarchy.ontologyAssertions);
    }

    getPropertyAdvicesForClass(ontologyClass: IOntologyClass) {
        var propertiesProvider = this.propertySelector.getPropertiesFor(ontologyClass);
        var chunkedProperties = propertiesProvider.getPropertiesByChunk();
        return chunkedProperties;
    }

    getAdvicesForVariable(
        context: QueryClassInferencerResult,
        inferenceVariable: InferenceVariable,
        prefixes: { [key: string]: string }): IQueryAdvice {

        if (inferenceVariable.isRdfTypeObject) {
            var allAtomicClasses = this.ontologyHierarchy.ontologyAssertions.classes
                .filter(x => (x instanceof AtomicClass))
                .map(x => (<AtomicClass>x).iri);

            return new RdfTypeQueryAdvice(allAtomicClasses);
        }

        if (inferenceVariable.subjectVariableName != null) {
            var inferenceVariable = context.getVariable(inferenceVariable.subjectVariableName)
            if (inferenceVariable != null && inferenceVariable.possibleClasses.length > 0) {
                var structuredAdvices = this.getPropertyAdvicesForClass(inferenceVariable.possibleClasses[0]);
                return new PropertyQueryAdvice(inferenceVariable.possibleClasses, structuredAdvices, prefixes);
            }
        }
        return null;
    }

    inferVariableAdvices(query: any, variableName: string): IQueryAdvice {
        var context = this.classInferencer.inferClasses(query);

        var inferenceVariable = context.getVariable(variableName);
        if (inferenceVariable == null) {
            return null;
        }

        var result = this.getAdvicesForVariable(context, inferenceVariable, query.prefixes);
        return result;
    }

    providePropertyAutocompletion(queryContent: string, cursorOffset: number) {
        try {
            var queryWithCursor = injectCursor(queryContent, cursorOffset);
            var parser = new ERSParser();
            return this.inferVariableAdvices(parser.parse(queryWithCursor).query, 'cursor');
        } catch (e) {
            this.logger.log(e);
            return null;
        }
    }

}