import { RdfIri } from "../../Utils/RdfIri";
import { AtomicClass, IOntologyClass } from "../../Ontology/OntologyClass";
import { Node, Block, NodeType, Triple } from "../Query/Query";
import { TriplesExplorer } from "../../Autocompletition/Inference/TriplesExplorer";
import { OntologyAssertions } from "../../Ontology/OntologyAssertions";

import * as _ from "lodash";

export class InferenceVariable {
    public possibleClasses: IOntologyClass[] = [];

    public isRdfTypeObject: boolean = false;

    /**In case the variable is predicate, stores link to subject variable. */
    public subjectVariableName: string;

    constructor(public name: string) {

    }

    public addPossibleClass(ontologyClass: IOntologyClass) {
        if (_(this.possibleClasses).some((possibleClass: IOntologyClass) => possibleClass.equal(ontologyClass))) {
            return;
        }
        this.possibleClasses.push(ontologyClass);
    }
}

export class QueryClassInferencerResult {
    public variables: InferenceVariable[] = [];

    getVariable(variableName: string) {
        var matchedVariables = this.variables.filter(x => x.name == variableName);
        var length = matchedVariables.length;
        if (length > 1) {
            throw new Error();
        }
        if (length == 0) {
            return null;
        }
        return matchedVariables[0];
    }

    getOrCreateVariable(variableName: string) {
        var inferenceVariable = this.getVariable(variableName);
        if (inferenceVariable == null) {
            inferenceVariable = new InferenceVariable(variableName);
            this.variables.push(inferenceVariable);
        }
        return inferenceVariable;
    }

    setVariableType(variableName: string, ontologyClass: IOntologyClass) {
        var inferenceVariable = this.getOrCreateVariable(variableName);
        inferenceVariable.addPossibleClass(ontologyClass);
    }

    setSubjectVariableName(variableName: string, subjectVariableName: string): any {
        this.getOrCreateVariable(variableName).subjectVariableName = subjectVariableName;
    }

    setVariableAsRdfTypeObject(variableName: string) {
        this.getOrCreateVariable(variableName).isRdfTypeObject = true;
    }

    propertyNodeSetVariable(subjectOrObject: Node, domainsOrRanges: IOntologyClass[]) {
        if (subjectOrObject.type != NodeType.Variable || domainsOrRanges == null) {
            return;
        }

        domainsOrRanges.forEach(domainOrRange => this.setVariableType(subjectOrObject.value, domainOrRange));
    }
}

export class QueryClassInferencer {

    private triplesExplorer: TriplesExplorer = new TriplesExplorer();

    constructor(private ontologyAssertions: OntologyAssertions) {
        // empty
    }

    private findAllRdfTypeTriples(block: Block) {
        var matchedTriples = block.match(null, RdfIri.rdfType, null);
        return matchedTriples
            .filter(x => x.subject.type == NodeType.Variable && x.object.type == NodeType.Iri)
            .map(x => ({
                variableName: x.subject.value,
                classIri: x.object.value
            }));
    }

    private findOrCreateOntologyClassForIri(classIri: string) {
        var ontologyClass: IOntologyClass = this.ontologyAssertions.findClassByIri(classIri);
        if (ontologyClass == null) {
            ontologyClass = new AtomicClass(classIri);
        }
        return ontologyClass;
    }

    private inferClassFromProperties(result: QueryClassInferencerResult, block: Block) {
        var rdfTypes = this.findAllRdfTypeTriples(block);
        rdfTypes.forEach(x => result.setVariableType(x.variableName, this.findOrCreateOntologyClassForIri(x.classIri)));

        block.triples
            .filter(triple => triple.predicate.type == NodeType.Iri)
            .forEach(triple => {
                var ontologyProperty = this.ontologyAssertions.findPropertyByName(triple.predicate.value);
                if (ontologyProperty != null) {
                    result.propertyNodeSetVariable(triple.subject, ontologyProperty.domains);
                    result.propertyNodeSetVariable(triple.object, ontologyProperty.ranges);
                }
            });

    }

    private markRdfTypeObjects(result: QueryClassInferencerResult, block: Block) {
        block.match(null, RdfIri.rdfType, null)
            .filter(triple => triple.object.type == NodeType.Variable)
            .forEach(triple => result.setVariableAsRdfTypeObject(triple.object.value));
    }

    private addPredicateLinksToSubject(result: QueryClassInferencerResult, block: Block) {
        block.triples
            .filter(triple => triple.predicate.type == NodeType.Variable && triple.subject.type == NodeType.Variable)
            .forEach(triple => result.setSubjectVariableName(triple.predicate.value, triple.subject.value));
    }

    private createQueryBlock(query: any) {
        var triples = this.triplesExplorer.findTriples(query);
        return new Block(triples);
    }

    inferClasses(query: any): QueryClassInferencerResult {
        var block = this.createQueryBlock(query);
        var result = new QueryClassInferencerResult();
        this.inferClassFromProperties(result, block);
        this.markRdfTypeObjects(result, block);
        this.addPredicateLinksToSubject(result, block);

        return result;
    }
}