import { RdfIri } from '../../Utils/RdfIri';
import { AtomicClass, IOntologyClass } from '../../Ontology/OntologyClass';
import { Node, Block, NodeType, Triple } from '../Query/Query';
import { OntologyHierarchy } from '../../Ontology/OntologyHierarchy';
import { TriplesExplorer } from '../../Autocompletition/Inference/TriplesExplorer';

import * as _ from 'lodash';

export class VariableItem {
    public possibleClasses: IOntologyClass[] = [];
    public isRdfTypeObject: boolean = false;
    /**In case the variable is predicate, stores link to subject variable. */
    public subjectVariableName: string;

    constructor(public name: string) {

    }

    public addPossibleClass(ontologyClass: IOntologyClass) {
        if (_(this.possibleClasses).some((possibleClass: IOntologyClass) => possibleClass.equal(ontologyClass))) {
            return;
        }
        this.possibleClasses.push(ontologyClass);
    }
}

export class QueryClassInferencerResult {
    public variables: VariableItem[] = [];

    getVariable(name: string) {
        var matchedVariables = this.variables.filter(x => x.name == name);
        var length = matchedVariables.length;
        if (length > 1) {
            throw new Error();
        }
        if (length == 0) {
            return null;
        }
        return matchedVariables[0];
    }
}

export class QueryClassInferencer {

    private triplesExplorer: TriplesExplorer = new TriplesExplorer();

    constructor(private ontologyHierarchy: OntologyHierarchy) {
        // empty
    }

    private extractAllVariablesNames(block: Block) {
        var result = _(block.triples)
            .map(x => x.getAllNodes())
            .flatten()
            .filter((x: Node) => x.type == NodeType.Variable)
            .map((x: Node) => x.value)
            .uniq()
            .value();
        return result;
    }

    private createResult(block: Block) {
        var variableNames = this.extractAllVariablesNames(block);
        var context = new QueryClassInferencerResult();
        for (var variableName of variableNames) {
            context.variables.push(new VariableItem(variableName));
        }
        return context;
    }

    private findAllRdfType(block: Block) {
        var matchedTriples = block.match(null, RdfIri.rdfType, null);
        return matchedTriples
            .filter(x => x.subject.type == NodeType.Variable &&
                x.object.type == NodeType.Iri)
            .map(x => ({
                variableName: x.subject.value,
                classIri: x.object.value
            }));
    }

    private setVariableType(result: QueryClassInferencerResult, variableName: string, ontologyClass: IOntologyClass) {
        var variableContext = result.getVariable(variableName);
        variableContext.addPossibleClass(ontologyClass);
    }

    private propertyNodeSetVariable(result: QueryClassInferencerResult, subjectOrObject: Node, domainsOrRanges: IOntologyClass[]) {
        if (subjectOrObject.type == NodeType.Variable && domainsOrRanges != null && domainsOrRanges.length > 0) {
            this.setVariableType(result, subjectOrObject.value, domainsOrRanges[0]);
        }
    }

    private findOrCreateOntologyClassForIri(classIri: string) {
        var ontologyClass: IOntologyClass = this.ontologyHierarchy.ontologyAssertions.findClassByIri(classIri);
        if (ontologyClass == null) {
            ontologyClass = new AtomicClass(classIri);
        }
        return ontologyClass;
    }

    private inferClassFromProperties(result: QueryClassInferencerResult, block: Block) {
        var rdfTypes = this.findAllRdfType(block);
        rdfTypes.forEach(x => this.setVariableType(result, x.variableName, this.findOrCreateOntologyClassForIri(x.classIri)));

        for (var triple of block.triples) {
            if (triple.predicate.type == NodeType.Iri) {
                var currentProperty = this.ontologyHierarchy.ontologyAssertions.findPropertyByName(triple.predicate.value);
                if (currentProperty != null) {
                    // Extreme Todo:
                    this.propertyNodeSetVariable(result, triple.subject, currentProperty.domains);
                    this.propertyNodeSetVariable(result, triple.object, currentProperty.ranges);
                }
            }
        }
    }

    private markRdfTypeObjects(result: QueryClassInferencerResult, block: Block) {
        var matchedTriples = block.match(null, RdfIri.rdfType, null);

        for (var matchedTriple of matchedTriples) {
            if (matchedTriple.object.type == NodeType.Variable) {
                var variable = result.getVariable(matchedTriple.object.value);
                variable.isRdfTypeObject = true;
            }
        }
    }

    private addPredicateLinksToSubject(result: QueryClassInferencerResult, block: Block) {
        for (var triple of block.triples) {
            var predicate = triple.predicate;
            var subject = triple.subject;

            if (triple.predicate.type == NodeType.Variable
                && triple.subject.type == NodeType.Variable) {
                result.getVariable(predicate.value).subjectVariableName = subject.value;
            }
        }
    }

    private createQueryBlock(query: any) {
        var triples = this.triplesExplorer.findTriples(query);
        return new Block(triples);
    }

    inferClasses(query: any): QueryClassInferencerResult {
        var block = this.createQueryBlock(query);
        var result = this.createResult(block);

        this.inferClassFromProperties(result, block);
        this.markRdfTypeObjects(result, block);
        this.addPredicateLinksToSubject(result, block);

        return result;
    }
}