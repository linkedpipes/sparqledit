import { IOntologyClass } from '../../Ontology/OntologyClass';
import { OntologyConcept } from '../../Ontology/OntologyConcept';
import { getGraphTopologicalOrdering, TopologicalOrderingGraph } from '../../Ontology/Algorithms/TopologicalOrdering';
import { OntologyHierarchy as OntologyHierarchy } from '../../Ontology/OntologyHierarchy';
import { OntologyAssertions } from '../../Ontology/OntologyAssertions';
import { buildOntologyHierarchy } from '../../Ontology/Algorithms/OntologyHierarchyBuilder';
import { IParentOntologyClassTracker } from './ParentOntologyClassTracker';
import * as _ from "lodash";

function createSubsetOntologyAssertions(ontologyAssertions: OntologyAssertions, ontologyClasses: IOntologyClass[]) {
    var edges = _(ontologyClasses).map(subsetClass =>
        ontologyAssertions
            .findSuperSetClasses(subsetClass)
            .map(superset => ({ subset: subsetClass, superset: superset })))
        .flatten<{ subset: IOntologyClass, superset: IOntologyClass }>()
        .filter(edge => _(ontologyClasses).includes(edge.superset))
        .value();

    var subsetOntologyAssertions = new OntologyAssertions();
    edges.forEach(edge => subsetOntologyAssertions.addSubclassEdge(edge.subset, edge.superset))
    ontologyClasses.forEach(ontologyclass => subsetOntologyAssertions.addOrGetClassIndex(ontologyclass));
    return subsetOntologyAssertions;
}

function createTopologicalOrderingGraph(ontologyHierarchy: OntologyHierarchy): TopologicalOrderingGraph {
    var graph = new TopologicalOrderingGraph();
    graph.allocateNodes(ontologyHierarchy.concepts.length);
    var conceptIndexMapping = ontologyHierarchy.concepts.map((x, i) => ({ concept: x, index: i }));

    var index = 0;
    for (var ontologyConcept of ontologyHierarchy.concepts) {
        var superConcepts = ontologyHierarchy.getAllSuperClasses(ontologyConcept);
        for (var superConcept of superConcepts) {
            var conceptIndex = conceptIndexMapping.filter(y => y.concept == superConcept)[0].index;
            graph.addEdge(index, conceptIndex);
        }
        index++;
    }

    return graph;
}

export function createPropertyAdviceForOntologyClass(
    tracker: IParentOntologyClassTracker,
    ontologyAssertions: OntologyAssertions,
    ontologyClass: IOntologyClass)
    : OntologyConcept[] {
    if (ontologyAssertions.findClass(ontologyClass) == -1) {
        return [];
    }
    var reachableOntologyClasses = tracker.trackAcessibleClasses(ontologyAssertions, ontologyClass);
    var ontologyAssertions = createSubsetOntologyAssertions(ontologyAssertions, reachableOntologyClasses);
    var subsetOntologyHierarchy = buildOntologyHierarchy(ontologyAssertions);
    var topologicalOrderingGraph = createTopologicalOrderingGraph(subsetOntologyHierarchy);
    var topologicalOrdering = getGraphTopologicalOrdering(topologicalOrderingGraph);
    var orderedConcepts = topologicalOrdering.map(x => subsetOntologyHierarchy.concepts[x]);
    return orderedConcepts;
}