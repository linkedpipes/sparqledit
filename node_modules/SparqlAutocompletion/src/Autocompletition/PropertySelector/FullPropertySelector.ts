import { IOntologyClass } from '../../Ontology/OntologyClass';
import { orderTopologically, MyGraph } from '../../Ontology/Algorithms/TopologyOrder';
import { OntologyProperty, OntologyAssertions } from '../../Ontology/OntologyAssertions';
import { OntologyConcept, OntologyHiearchy } from '../../Ontology/OntologyHierchy';
import { IPropertySelector, PropertyForConceptProvider } from '../PropertySelector/IPropertySelector';

export interface IReachableConceptResult {
    root: OntologyConcept
    visitedStates: { concept: OntologyConcept, superClassConcept: OntologyConcept[] }[];
}

export class FullPropertySelector implements IPropertySelector {

    constructor(private ontologyHiarchy: OntologyHiearchy) {

    }

    getAllReachableSuperClassesConcepts(concept: OntologyConcept): IReachableConceptResult {
        var stateStack: OntologyConcept[] = [concept];
        var visitedStates: { concept: OntologyConcept, superClassConcept: OntologyConcept[] }[] = [];

        while (stateStack.length > 0) {
            var currentConcept = stateStack.pop();
            var currentSuperClasses = this.ontologyHiarchy.getAllSuperClasses(currentConcept);
            visitedStates.push({ concept: currentConcept, superClassConcept: currentSuperClasses });
            currentSuperClasses.forEach(concept => {
                if (!visitedStates.some(x => x.concept === concept)) {
                    stateStack.push(concept);
                }
            });
        }

        return {
            root: concept,
            visitedStates: visitedStates
        };
    }

    createAdjcencyList(input: IReachableConceptResult) {
        var nodes = input.visitedStates.map((x, i) => ({ concept: x.concept, index: i, edges: [] }));
        var index = 0;
        for (var state of input.visitedStates) {
            nodes[index].edges = state.superClassConcept.map(x => {
                nodes.filter(y => y.concept == x)[0].index;
            });
            index++;
        }
        return nodes;
    }

    createMyGraphFromReachableConcepts(input: IReachableConceptResult) {
        var myGraph = new MyGraph();
        myGraph.allocateNode(input.visitedStates.length);
        var conceptIndexMapping = input.visitedStates.map((x, i) => ({ concept: x.concept, index: i }));

        var index = 0;
        for (var state of input.visitedStates) {
            for (var superClassconcept of state.superClassConcept) {
                var conceptIndex = conceptIndexMapping.filter(y => y.concept == superClassconcept)[0].index;
                myGraph.addEdge(index, conceptIndex);
            }
            index++;
        }

        return myGraph;
    }

    getPropertiesFor(ontologyClass: IOntologyClass) {
        var concept = this.ontologyHiarchy.getConceptContainsOntologyClass(ontologyClass);
        // TODO:what if concept is null
        var reachableConcepts = this.getAllReachableSuperClassesConcepts(concept);
        var graphOfConcepts = this.createMyGraphFromReachableConcepts(reachableConcepts);
        var order = orderTopologically(graphOfConcepts);
        var orderedConcepts = order.map(x => reachableConcepts.visitedStates[x].concept);
        return new PropertyForConceptProvider(orderedConcepts, this.ontologyHiarchy);
    }
}