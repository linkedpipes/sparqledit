import { IOntologyClass } from '../../Ontology/OntologyClass';
import { getGraphTopologicalOrdering, TopologicalOrderingGraph } from '../../Ontology/Algorithms/TopologicalOrdering';
import { OntologyConcept, OntologyHierarchy } from '../../Ontology/OntologyHierarchy';
import { IPropertySelector  } from '../PropertySelector/IPropertySelector';

export interface VisitedOntologyConcept {
    concept: OntologyConcept;
    superClassConcept: OntologyConcept[];
}

export class FullPropertySelector implements IPropertySelector {

    constructor(private ontologyHiarchy: OntologyHierarchy) {

    }

    getAllReachableSuperClassesConcepts(concept: OntologyConcept): VisitedOntologyConcept[] {
        var stateStack: OntologyConcept[] = [concept];
        var visitedConcepts: { concept: OntologyConcept, superClassConcept: OntologyConcept[] }[] = [];

        while (stateStack.length > 0) {
            var currentConcept = stateStack.pop();
            if (!visitedConcepts.some(x => x.concept === currentConcept)) {
                var currentSuperClasses = this.ontologyHiarchy.getAllSuperClasses(currentConcept);
                visitedConcepts.push({ concept: currentConcept, superClassConcept: currentSuperClasses });

                currentSuperClasses.forEach(concept => {
                    stateStack.push(concept);
                });
            }
        }

        return visitedConcepts;
    }

    createTopologicalOrderingGraphFromReachableConcepts(visitedOntologyConcepts: VisitedOntologyConcept[]) {
        var graph = new TopologicalOrderingGraph();
        graph.allocateNodes(visitedOntologyConcepts.length);
        var conceptIndexMapping = visitedOntologyConcepts.map((x, i) => ({ concept: x.concept, index: i }));

        var index = 0;
        for (var state of visitedOntologyConcepts) {
            for (var superClassconcept of state.superClassConcept) {
                var conceptIndex = conceptIndexMapping.filter(y => y.concept == superClassconcept)[0].index;
                graph.addEdge(index, conceptIndex);
            }
            index++;
        }

        return graph;
    }

    getPropertiesFor(ontologyClass: IOntologyClass) {
        var concept = this.ontologyHiarchy.getConceptContainsOntologyClass(ontologyClass);
        var visitedOntologyConcepts = this.getAllReachableSuperClassesConcepts(concept);
        var graphOfConcepts = this.createTopologicalOrderingGraphFromReachableConcepts(visitedOntologyConcepts);
        var topologicalOrdering = getGraphTopologicalOrdering(graphOfConcepts);
        var orderedConcepts = topologicalOrdering.map(x => visitedOntologyConcepts[x].concept);
        return orderedConcepts;
    }
}