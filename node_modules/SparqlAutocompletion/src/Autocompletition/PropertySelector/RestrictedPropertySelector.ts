import { OntologyAssertions } from '../../Ontology/OntologyAssertions';
import { OntologyHierarchy, OntologyConcept } from '../../Ontology/OntologyHierarchy';
import { IOntologyClass } from '../../Ontology/OntologyClass';
import { IPropertySelector, PropertyForConceptProvider } from './IPropertySelector';

import * as _ from 'lodash'

export class NotAllContext {
    private _closedNodes: IOntologyClass[] = [];

    private stack: IOntologyClass[] = [];

    constructor(private ontologyAssertions: OntologyAssertions) {
        //empty
    }

    get closedNodes() {
        return this._closedNodes;
    }

    close(ontologyClass: IOntologyClass) {
        this._closedNodes.push(ontologyClass);
    }

    isClosed(ontologyClass: IOntologyClass) {
        return this._closedNodes.some(x => x.equal(ontologyClass));
    }

    isInStack(ontologyClass: IOntologyClass) {
        return this.stack.some(x => x.equal(ontologyClass));
    }

    push(ontologyClass: IOntologyClass) {
        this.stack.push(ontologyClass);
    }

    pop() {
        return this.stack.pop();
    }

    peek() {
        return this.stack[this.stack.length - 1];
    }

    existEdge(subsetClass: IOntologyClass, superClass: IOntologyClass) {
        return this.ontologyAssertions.existSubclassEdgeOntologyClass(subsetClass, superClass);
    }

    getEdges(ontologyClass: IOntologyClass) {
        var classNumber = this.ontologyAssertions.findClass(ontologyClass);
        var classes = this.ontologyAssertions.classes;
        return this.ontologyAssertions.subClassEdges
            .filter(x => x.subsetClass == classNumber)
            .map(x => classes[x.superClass]);
    }

    clone() {
        var result = new NotAllContext(this.ontologyAssertions);
        result.stack = this.stack.slice();
        result._closedNodes = this._closedNodes;
        return result;
    }
}

export class RestrictedPropertySelector implements IPropertySelector {

    constructor(private ontologyHiarchy: OntologyHierarchy) {
        
    }

    trackClass(ontologyAssertions: OntologyAssertions, ontologyClass: IOntologyClass) {
        var context = new NotAllContext(ontologyAssertions);
        context.push(ontologyClass);
        this.trackClassRecursive(context);
        return context.closedNodes;
    }

    trackClassRecursive(context: NotAllContext) {
        var currentNodeClass = context.peek();
        var edgeNodes = context.getEdges(currentNodeClass);
        for (var edgeNode of edgeNodes) {
            var isEquivalentEdge = context.existEdge(edgeNode, currentNodeClass);
            if (!isEquivalentEdge &&
                !context.isClosed(edgeNode) &&
                !context.isInStack(edgeNode)) {

                var newContext = context.clone();
                newContext.push(edgeNode);
                this.trackClassRecursive(newContext);
            }
        }
        context.pop();
        context.close(currentNodeClass);
    }

    getPropertiesFor(ontologyClass: IOntologyClass): PropertyForConceptProvider {
        var ontologyClasses = this.trackClass(this.ontologyHiarchy.ontologyAssertions, ontologyClass);
        var concepts = ontologyClasses.map(ontologyClass => new OntologyConcept([ontologyClass]));
        return new PropertyForConceptProvider(concepts, this.ontologyHiarchy);
    }
}