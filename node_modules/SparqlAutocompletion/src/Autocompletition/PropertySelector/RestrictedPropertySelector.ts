import { OntologyAssertions } from '../../Ontology/OntologyAssertions';
import { OntologyHierarchy } from '../../Ontology/OntologyHierarchy';
import { IOntologyClass } from '../../Ontology/OntologyClass';
import { IPropertySelector, PropertyForConceptProvider } from './IPropertySelector';
import { OntologyHierarchyBuilder } from 'SparqlAutocompletion/src/Ontology/Algorithms/OntologyHierarchyBuilder';
import { TopologicalOrderingGraph, getGraphTopologicalOrdering } from 'SparqlAutocompletion/src/Ontology/Algorithms/TopologicalOrdering';

import * as _ from 'lodash'

export class RestrictedPropertySelector implements IPropertySelector {

    private ontologyAssertions: OntologyAssertions;

    constructor(private ontologyHierarchy: OntologyHierarchy) {
        this.ontologyAssertions = ontologyHierarchy.ontologyAssertions;
    }

    private getOnlySuperSetEdges(ontologyClass: IOntologyClass) {
        return this.ontologyAssertions
            .findSuperSetClasses(ontologyClass)
            .filter(x => !this.ontologyAssertions.existSubclassEdgeOntologyClass(x, ontologyClass))
    }

    trackOnlySuperSetClasses(visitedClasses: IOntologyClass[], ontologyClass: IOntologyClass) {
        if (visitedClasses.filter(x => x == ontologyClass).length > 0) {
            return;
        }
        visitedClasses.push(ontologyClass);

        for (var superSetClass of this.getOnlySuperSetEdges(ontologyClass)) {
            this.ontologyAssertions.addSubclassEdge(ontologyClass, superSetClass);
            this.trackOnlySuperSetClasses(visitedClasses, superSetClass);
        }
        return visitedClasses;
    }

    createSubsetOntologyAssertions(ontologyClasses: IOntologyClass[]) {
        var edges = _(ontologyClasses).map(subsetClass =>
            this.ontologyAssertions
                .findSuperSetClasses(subsetClass)
                .map(superset => ({ subset: subsetClass, superset: superset }))
        )
        .flatten<{ subset: IOntologyClass, superset: IOntologyClass }>()
        .filter(edge => _(ontologyClasses).includes(edge.superset))
        .value();

        var ontologyAssertions = new OntologyAssertions();
        edges.forEach(edge => ontologyAssertions.addSubclassEdge(edge.subset, edge.superset))
        return ontologyAssertions;
    }

    createSubsetOntologyHierarchy(ontologyHierarchy: OntologyHierarchy) {
        var graph = new TopologicalOrderingGraph();
        graph.allocateNodes(ontologyHierarchy.concepts.length);
        var conceptIndexMapping = ontologyHierarchy.concepts.map((x, i) => ({ concept: x, index: i }));

        var index = 0;
        for (var ontologyConcept of ontologyHierarchy.concepts) {
            var superConcepts = ontologyHierarchy.getAllSuperClasses(ontologyConcept);
            for (var superConcept of superConcepts) {
                var conceptIndex = conceptIndexMapping.filter(y => y.concept == superConcept)[0].index;
                graph.addEdge(index, conceptIndex);
            }
            index++;
        }

        return graph;
    }

    getPropertiesFor(ontologyClass: IOntologyClass): PropertyForConceptProvider {
        var reachableOntologyClasses = this.trackOnlySuperSetClasses([], ontologyClass);
        var ontologyAssertions = this.createSubsetOntologyAssertions(reachableOntologyClasses);
        var ontologyHierarchyBuilder = new OntologyHierarchyBuilder();
        var subsetOntologyHierarchy = ontologyHierarchyBuilder.createOntologyHierarchy(ontologyAssertions);
        var topologicalOrderingGraph = this.createSubsetOntologyHierarchy(subsetOntologyHierarchy);
        var topologicalOrdering = getGraphTopologicalOrdering(topologicalOrderingGraph);
        var orderedConcepts = topologicalOrdering.map(x => subsetOntologyHierarchy.concepts[x]);
        return new PropertyForConceptProvider(orderedConcepts, this.ontologyHierarchy);
    }
}