import { IReachableConceptResult } from './FullPropertySelector';
import { OntologyAssertions } from '../../Ontology/OntologyAssertions';
import { OntologyHierarchy, OntologyConcept } from '../../Ontology/OntologyHierarchy';
import { MyGraph } from '../../Ontology/Algorithms/TopologyOrder';
import { IOntologyClass } from '../../Ontology/OntologyClass';
import { IPropertySelector, PropertyForConceptProvider } from './IPropertySelector';

import * as _ from 'lodash'

export class NotAllContext {
    private _closedNodes: IOntologyClass[] = [];

    private stack: IOntologyClass[] = [];

    constructor(private ontologyAssertions: OntologyAssertions) {
        //empty
    }

    get closedNodes() {
        return this._closedNodes;
    }

    close(ontologyClass: IOntologyClass) {
        this._closedNodes.push(ontologyClass);
    }

    isClosed(ontologyClass: IOntologyClass) {
        return this._closedNodes.some(x => x.equal(ontologyClass));
    }

    isInStack(ontologyClass: IOntologyClass) {
        return this.stack.some(x => x.equal(ontologyClass));
    }

    push(ontologyClass: IOntologyClass) {
        this.stack.push(ontologyClass);
    }

    pop() {
        return this.stack.pop();
    }

    peek() {
        return this.stack[this.stack.length - 1];
    }

    existEdge(subsetClass: IOntologyClass, superClass: IOntologyClass) {
        return this.ontologyAssertions.existSubclassEdgeOntologyClass(subsetClass, superClass);
    }

    getEdges(ontologyClass: IOntologyClass) {
        var classNumber = this.ontologyAssertions.findClass(ontologyClass);
        var classes = this.ontologyAssertions.classes;
        return this.ontologyAssertions.subClassEdges
            .filter(x => x.subsetClass == classNumber)
            .map(x => classes[x.superClass]);
    }

    clone() {
        var result = new NotAllContext(this.ontologyAssertions);
        result.stack = this.stack.slice();
        result._closedNodes = this._closedNodes;
        return result;
    }
}

export class RestrictedPropertySelector implements IPropertySelector {

    constructor(private ontologyHiarchy: OntologyHierarchy) {

    }

    getAllReachableSuperClassesConcepts(concept: OntologyConcept): IReachableConceptResult {
        var stateStack: OntologyConcept[] = [concept];
        var visitedStates: { concept: OntologyConcept, superClassConcept: OntologyConcept[] }[] = [];

        while (stateStack.length > 0) {
            var currentConcept = stateStack.pop();
            var currentSuperClasses = this.ontologyHiarchy.getAllSuperClasses(currentConcept);
            visitedStates.push({ concept: currentConcept, superClassConcept: currentSuperClasses });
            currentSuperClasses.forEach(concept => {
                if (!visitedStates.some(x => x.concept === concept)) {
                    stateStack.push(concept);
                }
            });
        }

        return {
            root: concept,
            visitedStates: visitedStates
        };
    }

    createAdjcencyList(input: IReachableConceptResult) {
        var nodes = input.visitedStates.map((x, i) => ({ concept: x.concept, index: i, edges: [] }));
        var index = 0;
        for (var state of input.visitedStates) {
            nodes[index].edges = state.superClassConcept.map(x => {
                nodes.filter(y => y.concept == x)[0].index;
            });
            index++;
        }
        return nodes;
    }

    createMyGraphFromReachableConcepts(input: IReachableConceptResult) {
        var myGraph = new MyGraph();
        myGraph.allocateNode(input.visitedStates.length);
        var conceptIndexMapping = input.visitedStates.map((x, i) => ({ concept: x.concept, index: i }));

        var index = 0;
        for (var state of input.visitedStates) {
            for (var superClassconcept of state.superClassConcept) {
                var conceptIndex = conceptIndexMapping.filter(y => y.concept == superClassconcept)[0].index;
                myGraph.addEdge(index, conceptIndex);
            }
            index++;
        }

        return myGraph;
    }

    trackClass(ontologyAssertions: OntologyAssertions, ontologyClass: IOntologyClass) {
        var context = new NotAllContext(ontologyAssertions);
        context.push(ontologyClass);
        this.trackClassRecursive(context);
        return context.closedNodes;
    }

    trackClassRecursive(context: NotAllContext) {
        var currentNodeClass = context.peek();
        var edgeNodes = context.getEdges(currentNodeClass);
        for (var edgeNode of edgeNodes) {
            var isEquivalentEdge = context.existEdge(edgeNode, currentNodeClass);
            if (!isEquivalentEdge &&
                !context.isClosed(edgeNode) &&
                !context.isInStack(edgeNode)) {

                var newContext = context.clone();
                newContext.push(edgeNode);
                this.trackClassRecursive(newContext);
            }
        }
        context.pop();
        context.close(currentNodeClass);
    }

    getPropertiesFor(ontologyClass: IOntologyClass): PropertyForConceptProvider {
        // var reachableConcepts = this.getAllReachableSuperClassesConcepts(concept);
        // var graphOfConcepts = this.createMyGraphFromReachableConcepts(reachableConcepts);
        // var order = orderTopologically(graphOfConcepts);
        // var orderedConcepts = order.map(x => reachableConcepts.visitedStates[x].concept);
        var ontologyClasses = this.trackClass(this.ontologyHiarchy.ontologyAssertions, ontologyClass);
        var concepts = ontologyClasses.map(ontologyClass => new OntologyConcept([ontologyClass]));
        return new PropertyForConceptProvider(concepts, this.ontologyHiarchy);
    }
}