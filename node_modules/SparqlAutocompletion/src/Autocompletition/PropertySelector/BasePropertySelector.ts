import { IOntologyClass } from '../../Ontology/OntologyClass';
import { getGraphTopologicalOrdering, TopologicalOrderingGraph } from '../../Ontology/Algorithms/TopologicalOrdering';
import { OntologyHierarchy as OntologyHierarchy } from '../../Ontology/OntologyHierarchy';
import { OntologyConcept } from "../../Ontology/OntologyConcept";
import { IPropertySelector } from '../PropertySelector/IPropertySelector';
import { OntologyAssertions } from '../../Ontology/OntologyAssertions';
import { OntologyHierarchyBuilder } from '../../Ontology/Algorithms/OntologyHierarchyBuilder';
import * as _ from "lodash";

export abstract class BasePropertySelector implements IPropertySelector {

    constructor(protected ontologyAssertions: OntologyAssertions) {
        // empty 
    }

    abstract getAcessibleClasses(ontologyClass: IOntologyClass): ReadonlyArray<IOntologyClass>;

    trackAcessibleClasses(visitedClasses: IOntologyClass[], ontologyClass: IOntologyClass) {
        if (visitedClasses.filter(x => x == ontologyClass).length > 0) {
            return;
        }
        visitedClasses.push(ontologyClass);

        for (var superSetClass of this.getAcessibleClasses(ontologyClass)) {
            this.ontologyAssertions.addSubclassEdge(ontologyClass, superSetClass);
            this.trackAcessibleClasses(visitedClasses, superSetClass);
        }
        return visitedClasses;
    }

    createSubsetOntologyAssertions(ontologyClasses: IOntologyClass[]) {
        var edges = _(ontologyClasses).map(subsetClass =>
            this.ontologyAssertions
                .findSuperSetClasses(subsetClass)
                .map(superset => ({ subset: subsetClass, superset: superset }))
        )
            .flatten<{ subset: IOntologyClass, superset: IOntologyClass }>()
            .filter(edge => _(ontologyClasses).includes(edge.superset))
            .value();

        var ontologyAssertions = new OntologyAssertions();
        edges.forEach(edge => ontologyAssertions.addSubclassEdge(edge.subset, edge.superset))
        ontologyClasses.forEach(ontologyclass => ontologyAssertions.addOrGetClassIndex(ontologyclass));
        return ontologyAssertions;
    }

    createTopologicalOrderingGraph(ontologyHierarchy: OntologyHierarchy): TopologicalOrderingGraph {
        var graph = new TopologicalOrderingGraph();
        graph.allocateNodes(ontologyHierarchy.concepts.length);
        var conceptIndexMapping = ontologyHierarchy.concepts.map((x, i) => ({ concept: x, index: i }));

        var index = 0;
        for (var ontologyConcept of ontologyHierarchy.concepts) {
            var superConcepts = ontologyHierarchy.getAllSuperClasses(ontologyConcept);
            for (var superConcept of superConcepts) {
                var conceptIndex = conceptIndexMapping.filter(y => y.concept == superConcept)[0].index;
                graph.addEdge(index, conceptIndex);
            }
            index++;
        }

        return graph;
    }

    getPropertiesFor(ontologyClass: IOntologyClass): OntologyConcept[] {
        if (this.ontologyAssertions.findClass(ontologyClass) == -1) {
            return [];
        }
        var reachableOntologyClasses = this.trackAcessibleClasses([], ontologyClass);
        var ontologyAssertions = this.createSubsetOntologyAssertions(reachableOntologyClasses);
        var ontologyHierarchyBuilder = new OntologyHierarchyBuilder();
        var subsetOntologyHierarchy = ontologyHierarchyBuilder.createOntologyHierarchy(ontologyAssertions);
        var topologicalOrderingGraph = this.createTopologicalOrderingGraph(subsetOntologyHierarchy);
        var topologicalOrdering = getGraphTopologicalOrdering(topologicalOrderingGraph);
        var orderedConcepts = topologicalOrdering.map(x => subsetOntologyHierarchy.concepts[x]);
        return orderedConcepts;
    }
}