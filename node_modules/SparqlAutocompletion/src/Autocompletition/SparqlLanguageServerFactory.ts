import { Serializer } from '../Serialization/Serializer';
import { SparqlLanguageServer } from './SparqlLanguageServer';
import { OntologyAssertionsBuilder } from '../Ontology/Algorithms/OntologyAssertionBuilder';
import { OntologyHiearchy } from "../Ontology/OntologyHierchy"
import { TurtleGraphWrapper } from '../GraphTools/TurtleGraphWrapper';
import { error } from 'util';
import { ISparqlLanguageServerSettings } from 'SparqlAutocompletion/src/Autocompletition/SparqlLanguageServerSettings';

export class SparqlLanguageServerFactory {

    public createFromTurtle(ontologyContent: string, sparqlLanguageServerSettings: ISparqlLanguageServerSettings, forbiddenSources: string[] = []): SparqlLanguageServer {
        return this.createFromMultipleTurtle([ontologyContent], sparqlLanguageServerSettings, forbiddenSources);
    }

    public createFromMultipleTurtle(ontologyContents: string[], sparqlLanguageServerSettings: ISparqlLanguageServerSettings, forbiddenSources: string[] = []): SparqlLanguageServer {
        var ontologyAssertionsBuilder = new OntologyAssertionsBuilder();
        var graphs = ontologyContents.map(x => new TurtleGraphWrapper(x, forbiddenSources));
        var ontologyAssertionsResult = ontologyAssertionsBuilder.buildOntologyAsertionsMultipleGraphs(graphs);
        return new SparqlLanguageServer(ontologyAssertionsResult.ontologyAssertions, sparqlLanguageServerSettings);
    }

    public createFromSerializedOntologyAssertions(serializedOntologyAssertions: string, sparqlLanguageServerSettings: ISparqlLanguageServerSettings): SparqlLanguageServer {
        var serializer = new Serializer();
        var ontologyAssertions = serializer.deserializeOntologyAssertions(serializedOntologyAssertions);
        return new SparqlLanguageServer(ontologyAssertions, sparqlLanguageServerSettings);
    }

    /**
     * Creates SparqlLanguageServer from editor format. Editor format allows raw or precomputed ontologies input.  
     */
    public createFromEditorFormat(editorOntologyAssertions: string, sparqlLanguageServerSettings: ISparqlLanguageServerSettings) {
        try {
            var editorFormat = JSON.parse(editorOntologyAssertions);
        }
        catch{
            throw new Error("Wrong editor format: can not parse to JSON.");
        }

        if (!editorFormat.hasOwnProperty('type') || !editorFormat.hasOwnProperty('value')) {
            throw new Error("Wrong editor format: missing property type or value.");
        }

        switch (editorFormat.type) {
            case "raw":
                var forbiddenSources = editorFormat.forbiddenSources == null ? [] : editorFormat.forbiddenSources;
                return this.createFromTurtle(editorFormat.value, sparqlLanguageServerSettings, forbiddenSources);
            case "precomputed":
                return this.createFromSerializedOntologyAssertions(editorFormat.value, sparqlLanguageServerSettings);
            default:
                throw new Error("Wrong editor format: unknown format type.");
        }
    }
}