import { Serializer } from '../Serialization/Serializer';
import { SparqlLanguageServer } from './SparqlLanguageServer';
import { OntologyAssertionsBuilder } from '../Ontology/Algorithms/OntologyAssertionBuilder';
import { TurtleGraphWrapper } from '../GraphTools/TurtleGraphWrapper';
import { ISparqlLanguageServerSettings } from '../Autocompletition/SparqlLanguageServerSettings';
import { AlgorithmErrorLogger } from '../Ontology/Algorithms/Errors/AlgorithmErrors';

export interface SparqlLanguageServerFactoryResult {
    sparqlLanguageServer: SparqlLanguageServer;
    buildOntologyAlgorithmErrorLogger: AlgorithmErrorLogger
}

export class SparqlLanguageServerFactory {

    public createFromTurtle(ontologyContent: string, sparqlLanguageServerSettings: ISparqlLanguageServerSettings, forbiddenSources: string[] = [])
        : SparqlLanguageServerFactoryResult {
        return this.createFromMultipleTurtle([ontologyContent], sparqlLanguageServerSettings, forbiddenSources);
    }

    public createFromMultipleTurtle(ontologyContents: string[], sparqlLanguageServerSettings: ISparqlLanguageServerSettings, forbiddenSources: string[] = [])
        : SparqlLanguageServerFactoryResult {
        var ontologyAssertionsBuilder = new OntologyAssertionsBuilder();
        var graphs = ontologyContents.map(x => new TurtleGraphWrapper(x, forbiddenSources));
        var ontologyAssertionsResult = ontologyAssertionsBuilder.buildOntologyAsertionsMultipleGraphs(graphs);
        return {
            sparqlLanguageServer: new SparqlLanguageServer(ontologyAssertionsResult.ontologyAssertions, sparqlLanguageServerSettings),
            buildOntologyAlgorithmErrorLogger: ontologyAssertionsResult.algorithmErrorLogger
        };
    }

    public createFromSerializedOntologyAssertions(serializedOntologyAssertions: string, sparqlLanguageServerSettings: ISparqlLanguageServerSettings)
        : SparqlLanguageServerFactoryResult {
        var serializer = new Serializer();
        var ontologyAssertions = serializer.deserializeOntologyAssertions(serializedOntologyAssertions);
        return {
            sparqlLanguageServer: new SparqlLanguageServer(ontologyAssertions, sparqlLanguageServerSettings),
            buildOntologyAlgorithmErrorLogger: new AlgorithmErrorLogger()
        };
    }

    /**
     * Creates SparqlLanguageServer from editor format. Editor format allows raw or precomputed ontologies input.  
     */
    public createFromEditorFormat(editorOntologyAssertions: string, sparqlLanguageServerSettings: ISparqlLanguageServerSettings)
        : SparqlLanguageServerFactoryResult {
        try {
            var editorFormat = JSON.parse(editorOntologyAssertions);
        }
        catch{
            throw new Error("Wrong editor format: can not parse to JSON.");
        }

        if (!editorFormat.hasOwnProperty('type') || !editorFormat.hasOwnProperty('value')) {
            throw new Error("Wrong editor format: missing property type or value.");
        }

        switch (editorFormat.type) {
            case "raw":
                var forbiddenSources = editorFormat.forbiddenSources == null ? [] : editorFormat.forbiddenSources;
                return this.createFromTurtle(editorFormat.value, sparqlLanguageServerSettings, forbiddenSources);
            case "precomputed":
                return this.createFromSerializedOntologyAssertions(editorFormat.value, sparqlLanguageServerSettings);
            default:
                throw new Error("Wrong editor format: unknown format type.");
        }
    }
}