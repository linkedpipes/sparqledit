import { PluginManager } from '../plugins/PluginManager';
import { EditorSettingsStore } from '../store/EditorSettingsStore';
import { MonacoEditorWrapper } from "../components/MonacoEditorWrapper"
import { observable } from "EditorComponent/node_modules/mobx/lib/mobx";
import { ErrorConsole } from "../components/ErrorConsole";
import { ParserErrorStore } from "../store/ParserErrorsStore";
import { ToolRenderer } from "../components/ToolRenderer";
import { ToolStore } from "../store/ToolStore";
import { EditorPluginApi } from "../plugins/EditorPluginApi";
import * as React from "react";
import { observer } from "mobx-react";
import DevTools from 'mobx-react-devtools';
import MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';
import { EditorSettingsFactory } from "EditorComponent/src/factory/EditorSettingsFactory";
import { SplitterComponent } from 'EditorComponent/src/components/SplitterComponent';
import { EditorStatusStore, EditorStatus } from 'EditorComponent/src/store/EditorStatusStore';
import { SparqlEditorSettings } from 'EditorComponent/src/editor/SparqlEditorSettings';
import { SparqlLanguageService } from 'EditorComponent/src/service/SparqlLanguageService';
import { SparqlLanguageServer } from 'SparqlAutocompletion';

var injectTapEventPlugin = require("react-tap-event-plugin");
require("../css/editor.css");

export interface EditorAppProps {
    pluginManager: PluginManager;
    sparqlEditorSettings: SparqlEditorSettings
}

@observer
export class EditorApp extends React.Component<EditorAppProps, any> {
    private toolStore = new ToolStore();
    private parserErrorStore: ParserErrorStore = new ParserErrorStore();
    private editorSettingsStore: EditorSettingsStore;
    private editor: monaco.editor.IStandaloneCodeEditor;
    private editorStatusStore: EditorStatusStore;
    private sparqlLanguageServer: SparqlLanguageServer

    constructor(props: EditorAppProps) {
        super(props);
        injectTapEventPlugin();

        var editorSettingsFactory = new EditorSettingsFactory();
        this.editorSettingsStore = editorSettingsFactory.createEditorSettings();
        this.editorStatusStore = new EditorStatusStore();
        var sparqlLanguageService = new SparqlLanguageService();

        sparqlLanguageService.createtLanguageServer(props.sparqlEditorSettings,
            (sparqlLanguageServer) => {
                this.sparqlLanguageServer = sparqlLanguageServer;
                this.editorStatusStore.setActive();
            }, () => {
                this.editorStatusStore.setError('Error');
            })
    }

    setMonacoEditor(monacoEditor: monaco.editor.IStandaloneCodeEditor) {

        var editorPluginApi = new EditorPluginApi(
            monacoEditor,
            this.sparqlLanguageServer,
            this.editorSettingsStore,
            this.toolStore,
            this.parserErrorStore);
        this.editor = monacoEditor;
        this.props.pluginManager.initPlugins(editorPluginApi);
    }

    resetEditorLayout() {
        this.editor.layout();
    }

    renderActive() {
        return (
            <ToolRenderer toolStore={this.toolStore} resetEditorLayout={this.resetEditorLayout.bind(this)}>
                <SplitterComponent direction={"vertical"} isSecondPaneVisible={true} onLayoutChanged={this.resetEditorLayout.bind(this)}>
                    <MonacoEditorWrapper
                        monacoEditorUrl={this.props.sparqlEditorSettings.monacoEditorUrl}
                        defaultEditorValue={this.props.sparqlEditorSettings.defaultEditorValue}
                        setMonacoEditor={this.setMonacoEditor.bind(this)} />
                    <ErrorConsole parserErrorStore={this.parserErrorStore} />
                </SplitterComponent>
            </ToolRenderer>);
    }

    renderLoading() {
        return <div>Editor is Loading ...</div>;
    }

    renderError() {
        return <div>{this.editorStatusStore.getErrorMessage()}</div>;
    }

    renderBody() {

        switch (this.editorStatusStore.getEditorStatus()) {

            case EditorStatus.Active:
                return this.renderActive();
            case EditorStatus.Loading:
                return this.renderLoading();
            case EditorStatus.Error:
                return this.renderError();
            default:
                throw new Error("Unknown editor status.");
        }
    }

    render() {
        return (
            <MuiThemeProvider>
                <div>
                    {this.renderBody()}
                    <DevTools />
                </div>
            </MuiThemeProvider>
        );
    }
}