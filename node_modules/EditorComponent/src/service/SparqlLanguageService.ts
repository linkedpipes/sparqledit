import { SparqlLanguageServer, Serializer, TurtleGraphWrapper, OntologyHierarchyBuilder, OntologyAssertionsBuilder, SparqlAutocompleteProvider, SparqlSignatureHelpProvider, SparqlLanguageServerFactory } from "SparqlAutocompletion";
import { SparqlEditorSettings } from "EditorComponent/src/editor/SparqlEditorSettings";
import { createHttpRequest } from "EditorComponent/src/utils/HttpRequest";

function createSparqlLanguageServerBasedOnSourceType(ontologyContext: string, sparqlEditorSettings: SparqlEditorSettings) {
    var sparqlLanguageServerFactory = new SparqlLanguageServerFactory();
    var sparqlLanguageServerSettings = {
        propertySelectorType: sparqlEditorSettings.propertySelectorType,
        isLoggingEnabled: sparqlEditorSettings.isLoggingEnabled
    };

    var ontologySourceType = sparqlEditorSettings.ontologySourceType || "custom";

    switch (ontologySourceType) {
        case "custom":
            return sparqlLanguageServerFactory.createFromEditorFormat(ontologyContext, sparqlLanguageServerSettings);
        case "precomputed":
            return sparqlLanguageServerFactory.createFromSerializedOntologyAssertions(ontologyContext, sparqlLanguageServerSettings);
        case "raw":
            return sparqlLanguageServerFactory.createFromTurtle(ontologyContext, sparqlLanguageServerSettings);
        default:
            throw new Error("Unknown ontologySourceType.");
    }
}

export function createSparqlLanguageServer(
    sparqlEditorSettings: SparqlEditorSettings,
    resolve: (sparqlLanguageServer: SparqlLanguageServer) => void,
    reject: () => void) {

    createHttpRequest(sparqlEditorSettings.ontologySourceUrl,
        (responseContent) => {
            var sparqlLanguageServer = createSparqlLanguageServerBasedOnSourceType(responseContent, sparqlEditorSettings);
            resolve(sparqlLanguageServer);
        },
        () => {
            reject();
        }
    );
}