/// <reference path="../node_modules/monaco-editor/monaco.d.ts" />
import * as angular from 'angular';
import * as React from "react";
import * as ReactDOM from "react-dom";
import { EditorApp } from "./react/EditorApp";
var autocomplete = require('./autocomplete');
var main = require('./views/main.html');
var parserVisualiser: any = require('./parserVisualiser');
var ERSParser: any = require('ERSParser');

export class EditorComponent {
    constructor(public container: HTMLElement) {

    }
    public init() {
        var element = React.createElement(EditorApp, {});
        ReactDOM.render(element, this.container);
    }
}


function removeKeysFromStack(stack: any) {
    return Object.keys(stack).map(function (x) {
        return stack[x];
    });
}

function setParserResultInScope($scope: any, parserResult: any) {
    var parserErrors = [];
    if (parserResult.parserErrors) {
        parserErrors = parserResult.parserErrors;
        delete parserResult.parserErrors;
    }
    setEditorErrors(parserErrors);
    $scope.parserOutput = parserResult;
    $scope.parserErrors = parserErrors;
}

function runParser(parser: any, $scope: any, runLexer: any) {
    $scope.lexerErrorOutput = null;
    $scope.parserErrorOutput = null;
    var parserInput = $scope.queryInput;
    if (runLexer) {
        try {
            $scope.lexerOutput = parser.showTerminals(parserInput);
        }
        catch (error) {
            $scope.lexerOutput = null;
            $scope.lexerErrorOutput = error;
        }
    }

    try {
        var parserResult = parser.parse(parserInput);
        setParserResultInScope($scope, parserResult);
        $scope.parserLog = parser.parserDebugger;
    } catch (error) {
        $scope.parserLog = parser.parserDebugger;
        $scope.parserOutput = null;
        $scope.parserErrorOutput = {
            message: error.message,
            tracedParserErrors: parser.tracedParserErrors
        };
        if (parser.tracedParserErrors.length > 0) {
            var haltParserError = parser.tracedParserErrors[parser.tracedParserErrors.length - 1];
            var editorError = {
                type: 'unnexpected ' + haltParserError.problemToken,
                yylocStart: {
                    last_line: haltParserError.loc.first_line,
                    last_column: haltParserError.loc.first_column,
                    first_line: -1,
                    first_column: -1
                },
                yylocEnd: {
                    first_line: -1,
                    first_column: -1,
                    last_line: haltParserError.loc.last_line,
                    last_column: haltParserError.loc.last_column,
                }
            };
            setEditorErrors([editorError]);
        };
    }
}

var editor: any;

function setEditorErrors(errors: any) {
    // var model = editor.getModel();
    // var markers = errors.map(function (error:any) {
    //     return {
    //         severity: monaco.Severity.Error,
    //         code: null,
    //         source: null,
    //         startLineNumber: error.yylocStart.last_line,
    //         startColumn: error.yylocStart.last_column,
    //         endLineNumber: error.yylocEnd.last_line,
    //         endColumn: error.yylocEnd.last_column,
    //         message: error.type,
    //     }
    // });

    // monaco.editor.setModelMarkers(model, 'sparql', markers);
}

function initMonacoEditor(text: any, $scope: any) {
    (<any>window).requirejs.config({ paths: { 'vs': 'node_modules/monaco-editor/min/vs' } });
    (<any>window).requirejs(['vs/editor/editor.main'], function () {
        monaco.languages.register({ id: 'sparql' });
        editor = monaco.editor.create(document.getElementById('queryEditorContainer'), {
            value: text,
            language: 'sparql'
        });

        editor.onDidChangeModelContent(function (e: any) {
            $scope.$apply(function () {
                $scope.queryInput = editor.getValue();
                if ($scope.settings.items.interactiveMode) {
                    $scope.runNewParserClick();
                }
            });
        });

        monaco.languages.registerCompletionItemProvider('sparql', {
            provideCompletionItems: autocomplete.provideSparqlCompletionItems
        });

        // monaco.languages.registerSignatureHelpProvider('sparql', {
        //     signatureHelpTriggerCharacters: [' '],
        //     provideSignatureHelp: function (model, position) {
        //         return {
        //             activeParameter: 0,
        //             activeSignature: 0,
        //             signatures: [{
        //                 documentation: "doce",
        //                 label: "label",
        //                 parameters: [{
        //                     documentation: "param1",
        //                     label: "param"
        //                 },
        //                 {
        //                     documentation: "parad2",
        //                     label: "lssss"
        //                 }]
        //             }]
        //         }
        //     }
        // });
    });
}
