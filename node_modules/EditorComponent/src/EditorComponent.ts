/// <reference path="../node_modules/monaco-editor/monaco.d.ts" />
import * as angular from 'angular';
require('angular-cookies');
var autocomplete = require('./autocomplete');
var main = require('./views/main.html');
var parserVisualiser: any = require('./parserVisualiser');
var ERSParser: any = require('ERSParser');


export class EditorSettingItem {
    constructor(public name: string, title: string) {

    }
}

export class EditorSettings {
    itemsDefinitions: EditorSettingItem[] = [];
    items: { [key: string]: boolean } = {};

    registerItem(settingsItem: EditorSettingItem) {
        this.itemsDefinitions.push(settingsItem);
        this.items[settingsItem.name] = false;
        return this;
    }

    loadFromCookies($cookies: angular.cookies.ICookieStoreService) {
        this.itemsDefinitions.forEach(function (itemDefinition) {
            var itemName = itemDefinition.name;
            var itemValue = $cookies.get('settings.' + itemName) == 'true';
            this.items[itemName] = itemValue;
        }, this);
    }

    saveToCookies($cookies: angular.cookies.ICookieStoreService) {
        for (var itemName in this.items) {
            $cookies.put('settings.' + itemName, this.items[itemName]);
        }
    }
}
export class EditorComponent {
    constructor(public container: HTMLElement) {

    }

    public init() {
        this.container.insertAdjacentHTML("beforeend", "<sparqleditorcomponent></sparqleditorcomponent>");
        var sparqlEditorComponentApp = angular
            .module('sparqlEditorComponentApp', ['ngCookies']);

        // TODO: remove this and rewrite it to components            
        sparqlEditorComponentApp
            .run(['$templateCache', ($templateCache: any) => {
                $templateCache.put('views/debugger/parserDebuggerView.html', require('./views/debugger/parserDebuggerView.html'));
                $templateCache.put('views/parserVisualiserView.html', require('./views/parserVisualiserView.html'));
                $templateCache.put('views/settings.html', require('./views/settings.html'));
            }]);

        sparqlEditorComponentApp.directive("collapsible", ["$timeout", function ($timeout) {
            return {
                link: function (scope, element, attrs) {
                    $timeout(function () {
                        element.collapsible();
                    });
                }
            };
        }]);

        sparqlEditorComponentApp.component('editorsettings', {
            templateUrl: 'views/settings.html',
            bindings: { data: "=" },
            controller: ['$cookies', function ($cookies) {
                this.checkBoxChanged = function () {
                    this.data.saveToCookies($cookies);
                }
            }]
        });

        sparqlEditorComponentApp.component('sparqleditorcomponent', {
            template: main,
            controller: ['$scope', '$cookies', ($scope: any, $cookies: angular.cookies.ICookieStoreService) => {
                //$scope.getItemSetReferences = getItemSetReferences;

                $scope.settings = (new EditorSettings())
                    .registerItem(new EditorSettingItem('showLexerOutput', 'Show lexer output'))
                    .registerItem(new EditorSettingItem('showParserOutput', 'Show parser output'))
                    .registerItem(new EditorSettingItem('showParserLog', 'Show parser log'))
                    .registerItem(new EditorSettingItem('showParserStates', 'Show parser states'))
                    .registerItem(new EditorSettingItem('showStack', 'Show parser stack'))
                    .registerItem(new EditorSettingItem('interactiveMode', 'Interactive mode'));

                $scope.settings.loadFromCookies($cookies);

                $scope.parserLog = null;
                $scope.lexerOutput = null;
                $scope.parserOutput = null;
                $scope.parserErrorOutput = null;
                $scope.lexerErrorOutput = null;
                $scope.parserErrors = [];
                $scope.queryInput = $cookies.get('queryInput');
                $scope.parserVisualiser = $scope.settings.items.showParserStates ? new parserVisualiser(new ERSParser()) : {};

                initMonacoEditor($scope.queryInput, $scope);

                $scope.runNewParserClick = function () {
                    var parser = new ERSParser();
                    runParser(parser, $scope, true);
                };

                $scope.$watch('queryInput', function (newValue: any, oldValue: any) {
                    $cookies.put('queryInput', newValue);
                });
            }]
        });

        //console.log(neco);
        angular.bootstrap(this.container, ['sparqlEditorComponentApp']);
    }
}





function removeKeysFromStack(stack: any) {
    return Object.keys(stack).map(function (x) {
        return stack[x];
    });
}

function setParserResultInScope($scope: any, parserResult: any) {
    var parserErrors = [];
    if (parserResult.parserErrors) {
        parserErrors = parserResult.parserErrors;
        delete parserResult.parserErrors;
    }
    setEditorErrors(parserErrors);
    $scope.parserOutput = parserResult;
    $scope.parserErrors = parserErrors;
}

function runParser(parser: any, $scope: any, runLexer: any) {
    $scope.lexerErrorOutput = null;
    $scope.parserErrorOutput = null;
    var parserInput = $scope.queryInput;
    if (runLexer) {
        try {
            $scope.lexerOutput = parser.showTerminals(parserInput);
        }
        catch (error) {
            $scope.lexerOutput = null;
            $scope.lexerErrorOutput = error;
        }
    }

    try {
        var parserResult = parser.parse(parserInput);
        setParserResultInScope($scope, parserResult);
        $scope.parserLog = parser.parserDebugger;
    } catch (error) {
        $scope.parserLog = parser.parserDebugger;
        $scope.parserOutput = null;
        $scope.parserErrorOutput = {
            message: error.message,
            tracedParserErrors: parser.tracedParserErrors
        };
        if (parser.tracedParserErrors.length > 0) {
            var haltParserError = parser.tracedParserErrors[parser.tracedParserErrors.length - 1];
            var editorError = {
                type: 'unnexpected ' + haltParserError.problemToken,
                yylocStart: {
                    last_line: haltParserError.loc.first_line,
                    last_column: haltParserError.loc.first_column,
                    first_line: -1,
                    first_column: -1
                },
                yylocEnd: {
                    first_line: -1,
                    first_column: -1,
                    last_line: haltParserError.loc.last_line,
                    last_column: haltParserError.loc.last_column,
                }
            };
            setEditorErrors([editorError]);
        };
    }
}

var editor: any;

function setEditorErrors(errors: any) {
    // var model = editor.getModel();
    // var markers = errors.map(function (error:any) {
    //     return {
    //         severity: monaco.Severity.Error,
    //         code: null,
    //         source: null,
    //         startLineNumber: error.yylocStart.last_line,
    //         startColumn: error.yylocStart.last_column,
    //         endLineNumber: error.yylocEnd.last_line,
    //         endColumn: error.yylocEnd.last_column,
    //         message: error.type,
    //     }
    // });

    // monaco.editor.setModelMarkers(model, 'sparql', markers);
}

function initMonacoEditor(text: any, $scope: any) {
    (<any>window).requirejs.config({ paths: { 'vs': 'node_modules/monaco-editor/min/vs' } });
    (<any>window).requirejs(['vs/editor/editor.main'], function () {
        monaco.languages.register({ id: 'sparql' });
        editor = monaco.editor.create(document.getElementById('queryEditorContainer'), {
            value: text,
            language: 'sparql'
        });

        editor.onDidChangeModelContent(function (e: any) {
            $scope.$apply(function () {
                $scope.queryInput = editor.getValue();
                if ($scope.settings.items.interactiveMode) {
                    $scope.runNewParserClick();
                }
            });
        });

        monaco.languages.registerCompletionItemProvider('sparql', {
            provideCompletionItems: autocomplete.provideSparqlCompletionItems
        });

        // monaco.languages.registerSignatureHelpProvider('sparql', {
        //     signatureHelpTriggerCharacters: [' '],
        //     provideSignatureHelp: function (model, position) {
        //         return {
        //             activeParameter: 0,
        //             activeSignature: 0,
        //             signatures: [{
        //                 documentation: "doce",
        //                 label: "label",
        //                 parameters: [{
        //                     documentation: "param1",
        //                     label: "param"
        //                 },
        //                 {
        //                     documentation: "parad2",
        //                     label: "lssss"
        //                 }]
        //             }]
        //         }
        //     }
        // });
    });
}
