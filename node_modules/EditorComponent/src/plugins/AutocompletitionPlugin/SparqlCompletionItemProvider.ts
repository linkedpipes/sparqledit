import { AutocompleteProviderClass, OntologyHiearchy, OntologyAssertionsBuilder, OntologyHiearchyBuilder, TurtleGraphWrapper } from "SparqlAutocompletion";
import { ERSParser } from 'ERSParser';

export class SparqlCompletionItemProvider implements monaco.languages.CompletionItemProvider {
    private ontologyAssertionsBuilder = new OntologyAssertionsBuilder();
    private ontologyHiarchyBuilder = new OntologyHiearchyBuilder();
    private ontologyHiearchy: OntologyHiearchy;

    triggerCharacters: string[] = [];

    constructor() {
        console.log('Start preparing ontology hiearchy.')
        this.ontologyHiearchy = this.createOntologyHiearchyFromFile();
        console.log('Ontology hiearchy prepared.')
    }

    createDependencyProposals() {
        return [
            {
                label: '"label"',
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: '"DOc"',
                insertText: 'label',
                detail: '"detail"',
                filterText: 'bagr',
                sortText: "1"
            },
            {
                label: '"ns:jead"',
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: "Fast, unopinionated, minimalist web framework",
                insertText: '"express": "*"',
                sortText: "2"
            },
            {
                label: '"ns:dva"',
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: "Fast, unopinionated, minimalist web framework",
                insertText: '"express": "*"',
                sortText: "3"
            },
            {
                label: '"express"',
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: "Fast, unopinionated, minimalist web framework",
                insertText: '"express": "*"',
                sortText: "4"
            },
            {
                label: '"mkdirp"',
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: "Recursively mkdir, like <code>mkdir -p</code>",
                insertText: '"mkdirp": "*"',
                sortText: "5"
            },
            {
                label: '"lodash"',
                kind: monaco.languages.CompletionItemKind.Function,
                insertText: '"lodash": "*"',
                sortText: "6"
            },
        ];
    }

    takeWhileNotWhitespace(text: string) {
        for (var i = text.length - 1; i >= 0; i--) {
            if (text[i] == " ") {
                return text.substr(0, i);
            }
        }

        return "";
    }

    removeCharactersAfterCursor(text: string) {
        for (var i = 0; i < text.length; i++) {
            var currentCharacter = text[i];
            if (currentCharacter == '\n' || currentCharacter == '\r') {
                return '.' + text.substring(i, text.length);
            }
        }

        return "";
    }

    injectCursor(query: string, offset: number) {
        return this.injectTerminal(query, offset, "cursor");
    }

    injectUnknown(query: string, offset: number) {
        return this.injectTerminal(query, offset, "unknown");
    }

    injectTerminal(query: string, offset: number, terminal: string) {
        var beforeCursor = query.substring(0, offset);
        var atferCursor = query.substring(offset, query.length)
        return this.takeWhileNotWhitespace(beforeCursor) + ' ' + terminal + ' ' + this.removeCharactersAfterCursor(atferCursor);
    }

    createOntologyHiearchyFromFile() {
        var fileContent = require('raw-loader!../../resources/dbpedia.ttl');
        var ontologyAssertions = this.ontologyAssertionsBuilder.buildOntologyAsertions(new TurtleGraphWrapper(fileContent));
        var ontologyHiearchy = this.ontologyHiarchyBuilder.createOntologyHiearchy(ontologyAssertions);
        return ontologyHiearchy;
    }

    parseQueryFromFile(queryContent: string) {
        var parser = new ERSParser();
        var result = parser.parse(queryContent);
        return result.query;
    }

    doAutocomplete(queryContent: string) {
        var autocompleteProvider = new AutocompleteProviderClass(this.ontologyHiearchy);
        var query = this.parseQueryFromFile(queryContent);
        var autocompleteResult = autocompleteProvider.doAutocomplete(query);
        console.log(autocompleteResult);
        return autocompleteResult;
    }
    ontologyAutocompletition(model: monaco.editor.IReadOnlyModel, position: monaco.Position): monaco.languages.CompletionItem[] {
        var query = this.injectCursor(model.getValue(), model.getOffsetAt(position));
        try {
            var result = this.doAutocomplete(query);
        } catch (e) {
            console.log("Autocomplete broken.");
            return [];
        }
        console.log(query);

        var cursorContext = result.getVariableContext('cursor');
        if (cursorContext != null) {
            return cursorContext.possibleAdvices.map(x => ({
                label: x,
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: "None sadfdsafsad fsad sad fdsaf sad fsad fas dfsadfsadfsadfsaddsafs d sadfsdfsd",
                detail: "Documenta asdf asdf adsf asdf asdfasdfadsfas",
                insertText: '<' + x + '>',
                sortText: "2"
            }));
        }
        return [];

    }
    private supportedKeywords = ["cursor", "base", "prefix", "select", "distinct", "reduced", "as", "construct", "where", "describe", "ask",
        "from", "named", "group", "by", "having", "order", "asc", "desc", "limit", "offset", "values", "load", "silent",
        "into", "clear", "drop", "create", "add", "to", "move", "copy", "insert", "delete", "delete", "with", "delete", "insert",
        "using", "default", "graph", "all", "optional", "service", "bind", "undef", "minus", "union", "filter", "in", "not",
        "bound", "bnode", "concat", "coalesce", "if", "replace", "exists", "separator"];

    provideCompletionItems(model: monaco.editor.IReadOnlyModel, position: monaco.Position): monaco.languages.CompletionItem[] {
        var parser = new ERSParser();
        var query = this.injectUnknown(model.getValue(), model.getOffsetAt(position));
        console.log(query);
        var result = parser.parse(query);
        var errorWithUnknonw = result.tracedParserErrors.filter(x => x.problemToken == "UNKNOWN");
        if (errorWithUnknonw.length == 0) {
            console.log("NUla");
            console.log(result.tracedParserErrors);
            return [{
                label: "nic",
                kind: monaco.languages.CompletionItemKind.Keyword,
            }];
        }

        var expectedTokens = errorWithUnknonw[0].expected;

        var currentKeywords: string[] = expectedTokens;
        return currentKeywords.map(x => ({
            label: x,
            kind: monaco.languages.CompletionItemKind.Keyword,
            insertText: x
        }));
    }
}