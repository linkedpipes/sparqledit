import { EditorSettingsStore } from '../../../../store/EditorSettingsStore';
import * as React from "react";
import { observer } from "mobx-react";
import { JsonFormatter } from "../../../../components/utils/JsonFormatter"
import { List, ListItem, Divider, RaisedButton, Paper, Card, CardHeader, CardText } from "material-ui"
import { observable } from "mobx";
import { SparqlLanguageServer, OntologyAutocompleteSubProvider, OntologyConcept, OntologyProperty, OntologyHiearchy } from "SparqlAutocompletion";
import { CleanOntologyClassTextFormatter } from "SparqlAutocompletion";
import { IOntologyClass } from "SparqlAutocompletion";

export interface PropertyAutocompleteComponentProps {
    getEditorContentAndCursorPosition(): { content: string, position: number };
    editorSettingsStore: EditorSettingsStore;
    sparqlLanguageServer: SparqlLanguageServer;
}

@observer
export class PropertyAutocompleteComponent extends React.Component<PropertyAutocompleteComponentProps, any> {
    private ontologyHiearchy: OntologyHiearchy;
    private ontologyClassTextFormatter = new CleanOntologyClassTextFormatter();
    @observable
    private intelisenseResult: { concept: OntologyConcept, properties: OntologyProperty[] }[] = null;

    constructor() {
        super();
        this.showIntelisense = this.showIntelisense.bind(this);
    }

    componentDidMount() {

    }

    showIntelisense() {
        var editorContentAndPosition = this.props.getEditorContentAndCursorPosition();
        this.ontologyHiearchy = this.props.sparqlLanguageServer.ontologyHiearchy;
        this.intelisenseResult = (new OntologyAutocompleteSubProvider(this.ontologyHiearchy)).providePropertyAutocompletion(editorContentAndPosition.content, editorContentAndPosition.position);
    }

    renderClass(ontologyClass: IOntologyClass, classIndex: number) {
        return (
            <li key={classIndex}>
                <div style={{ backgroundColor: "#c5cFFF" }}> {ontologyClass.getText(this.ontologyClassTextFormatter)}</div>
                <ul className="propertyList">
                    {this.ontologyHiearchy.ontologyAssertions.findPropertiesByDomain(ontologyClass).map((property, propertyIndex) =>
                        <li key={propertyIndex}>{property.name}</li>)
                    }
                </ul>
            </li>
        );
    }

    renderConcept(ontologyConcept: OntologyConcept, conceptIndex: number) {
        return (
            <li key={conceptIndex}>
                <div style={{ backgroundColor: "#c5Eae9" }}>
                    {ontologyConcept.ontologyClasses.map((ontologyClass, classIndex) => <div key={classIndex}>{ontologyClass.getText(this.ontologyClassTextFormatter)}</div>)}
                </div>
                <ul className="classList">
                    {ontologyConcept.ontologyClasses.map((ontologyClass, classIndex) =>
                        this.renderClass(ontologyClass, classIndex)
                    )}
                </ul>
            </li>
        );
    }

    renderIntelisenseResult() {
        if (this.intelisenseResult == null) {
            return null
        }
        return (
            <div>
                <ul className="conceptList">
                    {
                        this.intelisenseResult.map((result, conceptIndex) => this.renderConcept(result.concept, conceptIndex))
                    }
                </ul>
            </div>
        )
    }

    render() {
        if (!this.props.editorSettingsStore.getSettings("showIntelisenseDemonstration")) {
            return null;
        }
        return (
            <Paper>
                <Card>
                    <CardHeader title="Intelisense demonstration" subtitle={null} />
                    <CardText>
                        <RaisedButton onClick={this.showIntelisense}>Show intelisense</RaisedButton>
                        <Paper className="intelisenseTree">
                            {this.renderIntelisenseResult()}
                        </Paper>
                    </CardText>
                </Card>
            </Paper>
        );
    }
}
