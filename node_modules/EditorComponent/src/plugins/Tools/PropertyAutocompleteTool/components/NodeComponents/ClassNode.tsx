import * as React from "react";
import { observer } from "mobx-react";
import { List, ListItem, Divider, RaisedButton, Paper, Card, CardHeader, CardText } from "material-ui"
import { observable } from "mobx";
import { SparqlLanguageServer, OntologyAutocompleteSubProvider, OntologyConcept, OntologyProperty, OntologyHiearchy } from "SparqlAutocompletion";
import { CleanOntologyClassTextFormatter } from "SparqlAutocompletion";
import { IOntologyClass } from "SparqlAutocompletion";
import { INodeFactoryContext, BaseNodeFactory } from "./NodeFactory";
import { ExpandableList, ExpandableListItem } from "../ExpandableList";
import { ClassNodeInput, PropertyNodeInput } from "./DataModel";
import * as _ from "lodash";

export interface ClassNodeProps {
    ontologyClasses: IOntologyClass[];
    isClassWithoutPropertiesShown: boolean
    renderListUnder(ontologyClass: PropertyNodeInput): JSX.Element;
    ontologyClassToClassNodeInput(ontologyClass: IOntologyClass): PropertyNodeInput;
}

export class ClassNodeComponent extends React.Component<ClassNodeProps, any> {
    private ontologyClassTextFormatter = new CleanOntologyClassTextFormatter();
    render() {
        return (
            <ul className="classList">
                {this.props.ontologyClasses.map((ontologyClass, classIndex) => {
                    var propertyInput = this.props.ontologyClassToClassNodeInput(ontologyClass);
                    if (!this.props.isClassWithoutPropertiesShown && propertyInput.ontologyProperties.length == 0) {
                        return null;
                    }
                    return (
                        <li key={classIndex}>
                            <div>{ontologyClass.getText(this.ontologyClassTextFormatter)}</div>
                            {this.props.renderListUnder(propertyInput)}
                        </li>)
                })}
            </ul>
        );
    }
}

export class ClassNodeFactory extends BaseNodeFactory<ClassNodeInput, PropertyNodeInput> {
    dataSelector(data: ClassNodeInput, nodeFactoryContext: INodeFactoryContext): PropertyNodeInput {

        var ontologyAssertions = data.ontologyHiearchy.ontologyAssertions;
        var properties = _(data.ontologyClasses)
            .map(x => ontologyAssertions.findPropertiesByDomain(x))
            .flatten<OntologyProperty>()
            .value();

        return {
            ontologyProperties: this.filterProperties(nodeFactoryContext.propertyAutocompleteOptions.searchText, properties)
        }
    }

    ontologyClassToClassNodeInput(classNodeInput: ClassNodeInput, searchText: string, ontologyClass: IOntologyClass): PropertyNodeInput {
        var properties = classNodeInput.ontologyHiearchy.ontologyAssertions.findPropertiesByDomain(ontologyClass);
        return {
            ontologyProperties: this.filterProperties(searchText, properties)
        }
    }

    filterProperties(searchText: string, properties: OntologyProperty[]) {
        if (searchText != "") {
            properties = properties.filter(property => property.name.indexOf(searchText) != -1);
        }
        return properties;
    }

    getListElement(data: ClassNodeInput, nodeFactoryContext: INodeFactoryContext): JSX.Element {
        var searchText = nodeFactoryContext.propertyAutocompleteOptions.searchText;
        return <ClassNodeComponent
            ontologyClasses={data.ontologyClasses}
            isClassWithoutPropertiesShown={nodeFactoryContext.propertyAutocompleteOptions.isClassWithoutPropertiesShown}
            ontologyClassToClassNodeInput={(ontologyClass) => this.ontologyClassToClassNodeInput(data, searchText, ontologyClass)}
            renderListUnder={(propertyNodeInput) => nodeFactoryContext.renderListUnder(propertyNodeInput)} />
    }
}