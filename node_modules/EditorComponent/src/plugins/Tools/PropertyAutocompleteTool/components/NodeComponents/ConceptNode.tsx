import * as React from "react";
import { observer } from "mobx-react";
import { List, ListItem, Divider, RaisedButton, Paper, Card, CardHeader, CardText } from "material-ui"
import { observable } from "mobx";
import { SparqlLanguageServer, OntologyAutocompleteSubProvider, OntologyConcept, OntologyProperty, OntologyHiearchy } from "SparqlAutocompletion";
import { CleanOntologyClassTextFormatter } from "SparqlAutocompletion";
import { IOntologyClass } from "SparqlAutocompletion";
import { INodeFactoryContext, BaseNodeFactory } from "./NodeFactory";
import { ConceptNodeInput, ClassNodeInput } from "./DataModel";
import * as _ from "lodash";

export interface ConceptNodeProps {
    ontologyConcepts: OntologyConcept[];
    renderListUnder(ontologyConcept: OntologyConcept): JSX.Element;
}

export class ConceptNodeComponent extends React.Component<ConceptNodeProps, any> {
    private ontologyClassTextFormatter = new CleanOntologyClassTextFormatter();

    render() {
        return (
            <ul className="conceptList">
                {
                    this.props.ontologyConcepts.map((ontologyConcept, conceptIndex) => (
                        <li key={conceptIndex}>
                            <div style={{ backgroundColor: "#c5Eae9" }}>
                                {ontologyConcept.ontologyClasses.map((ontologyClass, classIndex) => <div key={classIndex}>{ontologyClass.getText(this.ontologyClassTextFormatter)}</div>)}
                            </div>
                            {this.props.renderListUnder(ontologyConcept)}
                        </li>
                    ))
                }
            </ul>
        )
    }
}

export class ConceptNodeFactory extends BaseNodeFactory<ConceptNodeInput, ClassNodeInput> {

    dataSelector(data: ConceptNodeInput): ClassNodeInput {
        return {
            ontologyHiearchy: data.ontologyHiearchy,
            ontologyClasses: _(data.concepts)
                .map(x => x.ontologyClasses)
                .flatten<IOntologyClass>()
                .value()
        }
    }

    ontologyConceptToClassNodeInput(conceptNodeInput: ConceptNodeInput, ontologyConcept: OntologyConcept): ClassNodeInput {
        return {
            ontologyHiearchy: conceptNodeInput.ontologyHiearchy,
            ontologyClasses: ontologyConcept.ontologyClasses
        }
    }

    getListElement(data: ConceptNodeInput, nodeFactoryContext: INodeFactoryContext): JSX.Element {
        return (
            <ConceptNodeComponent
                ontologyConcepts={data.concepts}
                renderListUnder={(ontologyConcept) => nodeFactoryContext.renderListUnder(this.ontologyConceptToClassNodeInput(data, ontologyConcept))} />
        );
    }
}