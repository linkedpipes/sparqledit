import * as React from "react";
import { observer } from "mobx-react";
import { INodeFactoryCommon, INodeFactoryContext, NodeApi } from "./NodeFactory";
import { ConceptNodeInput, AutocompleteClass } from "./DataModel";
import { ConceptNodeFactory } from "./ConceptNode";
import { ClassNodeFactory } from "./ClassNode";
import { PropertyNodeFactory } from "./PropertyNode";
import { PropertyAutocompleteOptions } from "../../PropertyAutocompleteOptions";
import * as _ from "lodash"

export interface TreeProps {
    conceptNodeInput: ConceptNodeInput;
    propertyAutocompleteOptions: PropertyAutocompleteOptions;
    nodeApi: NodeApi;
}

class NodeFactoryContext implements INodeFactoryContext {
    private index = 0;

    constructor(
        private nodeApi: NodeApi,
        private nodeFactories: INodeFactoryCommon[],
        private isNodeFactoryActiveVector: boolean[],
        public propertyAutocompleteOptions: PropertyAutocompleteOptions) {
        // empty
    }

    private cloneAndSetIndex(index: number) {
        var result = new NodeFactoryContext(this.nodeApi, this.nodeFactories,
            this.isNodeFactoryActiveVector,
            this.propertyAutocompleteOptions);
        result.index = index;
        return result;
    }

    renderListUnder(data: any): JSX.Element {
        for (var index = this.index; index < this.nodeFactories.length; index++) {
            var currentFactory = this.nodeFactories[index];

            if (this.isNodeFactoryActiveVector[index]) {
                return currentFactory.getListElementCommon(data, this.cloneAndSetIndex(index + 1));
            }
            else {
                data = currentFactory.dataSelectorCommon(data, this);
            }
        }
        throw new Error("No other factory.");
    }

    getNodeApi(): NodeApi {
        return this.nodeApi;
    }
}

export interface TreeComponentDataDecorator {
    updateTree(root: ConceptNodeInput, context: NodeFactoryContext): void;
}

export class PropertyFilterDecorator implements TreeComponentDataDecorator {

    updateTree(root: ConceptNodeInput, context: NodeFactoryContext) {
        var searchText = context.propertyAutocompleteOptions.searchText;
        if (context.propertyAutocompleteOptions.searchText.length > 0) {
            searchText = searchText.toLowerCase();
            var autocompleteClasses = _(root.concepts)
                .map(x => x.classes)
                .flatten<AutocompleteClass>()
                .value();

            autocompleteClasses.forEach(autocompleteClass => {
                autocompleteClass.properties = autocompleteClass.properties.filter(property => property.toLowerCase().indexOf(searchText) != -1)
            });
        }
    }
}

export class EmptyNodesFilterDecorator implements TreeComponentDataDecorator {

    updateTree(root: ConceptNodeInput, context: NodeFactoryContext) {
        var isClassWithoutPropertiesShown = context.propertyAutocompleteOptions.isClassWithoutPropertiesShown;
        if (!isClassWithoutPropertiesShown) {
            root.concepts.forEach(autocompleteConcept =>
                autocompleteConcept.classes = autocompleteConcept.classes.filter(autocompleteClass => autocompleteClass.properties.length > 0)
            );
            root.concepts = root.concepts.filter(autocompleteConcept => autocompleteConcept.classes.length > 0);
        }
    }
}

@observer
export class TreeComponent extends React.Component<TreeProps, any> {
    nodeFactories: INodeFactoryCommon[];
    dataDecorators: TreeComponentDataDecorator[];
    isNodeFactoryActiveVector: boolean[];


    constructor() {
        super();
        this.nodeFactories = [new ConceptNodeFactory(), new ClassNodeFactory(), new PropertyNodeFactory()];
        this.dataDecorators = [new PropertyFilterDecorator(), new EmptyNodesFilterDecorator()];
    }

    cloneTree(root: ConceptNodeInput): ConceptNodeInput {
        var concepts = root.concepts.map(autocompleteConcept => {
            var classes = autocompleteConcept.classes.map(autocompleteClass => {
                return {
                    name: autocompleteClass.name,
                    properties: autocompleteClass.properties.slice(0) //clone
                };
            });

            return {
                classes: classes
            };
        });
        return { concepts: concepts };
    }

    applyDecorators(root: ConceptNodeInput, context: NodeFactoryContext): ConceptNodeInput {
        var currentRoot = root;
        for (var dataDecorator of this.dataDecorators) {
            currentRoot = this.cloneTree(currentRoot);
            dataDecorator.updateTree(currentRoot, context);
        }
        return currentRoot;
    }

    render() {
        var options = this.props.propertyAutocompleteOptions;
        this.isNodeFactoryActiveVector = [options.isOntologyConceptShown, options.isOntologyClassShown, true];
        var context = new NodeFactoryContext(this.props.nodeApi, this.nodeFactories, this.isNodeFactoryActiveVector, this.props.propertyAutocompleteOptions);
        return context.renderListUnder(this.applyDecorators(this.props.conceptNodeInput, context));
    }
}
