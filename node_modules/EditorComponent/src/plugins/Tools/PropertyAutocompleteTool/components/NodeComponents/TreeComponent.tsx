import * as React from "react";
import { observer } from "mobx-react";
import { List, ListItem, Divider, RaisedButton, Paper, Card, CardHeader, CardText } from "material-ui"
import { observable } from "mobx";
import { SparqlLanguageServer, OntologyConcept, OntologyProperty, OntologyHiearchy } from "SparqlAutocompletion";
import { CleanOntologyClassTextFormatter } from "SparqlAutocompletion";
import { IOntologyClass } from "SparqlAutocompletion";
import { INodeFactory, INodeFactoryCommon, INodeFactoryContext } from "./NodeFactory";
import { ConceptNodeInput, AutocompleteClass } from "./DataModel";
import { ConceptNodeFactory } from "./ConceptNode";
import { ClassNodeFactory } from "./ClassNode";
import { PropertyNodeFactory } from "./PropertyNode";
import { PropertyAutocompleteOptions } from "../../PropertyAutocompleteOptions";
import * as _ from "lodash"

export interface TreeProps {
    conceptNodeInput: ConceptNodeInput;
    propertyAutocompleteOptions: PropertyAutocompleteOptions;
    monacoEditor: monaco.editor.IStandaloneCodeEditor;
}

class NodeFactoryContext implements INodeFactoryContext {
    private index = 0;

    constructor(
        private monacoEditor: monaco.editor.IStandaloneCodeEditor,
        private nodeFactories: INodeFactoryCommon[],
        private isNodeFactoryActiveVector: boolean[],
        public propertyAutocompleteOptions: PropertyAutocompleteOptions) {
    }

    private cloneAndSetIndex(index: number) {
        var result = new NodeFactoryContext(this.monacoEditor, this.nodeFactories,
            this.isNodeFactoryActiveVector,
            this.propertyAutocompleteOptions);
        result.index = index;
        return result;
    }

    renderListUnder(data: any): JSX.Element {
        for (var index = this.index; index < this.nodeFactories.length; index++) {
            var currentFactory = this.nodeFactories[index];

            if (this.isNodeFactoryActiveVector[index]) {
                return currentFactory.getListElementCommon(data, this.cloneAndSetIndex(index + 1));
            }
            else {
                data = currentFactory.dataSelectorCommon(data, this);
            }
        }
        throw new Error("No other factory.");
    }

    insertPropertyIntoEditor(propertyName: string): void {
        var editorModel = this.monacoEditor.getModel();
        var editorValue = editorModel.getValue();
        var editorCursorIndex = editorModel.getOffsetAt(this.monacoEditor.getPosition());
        var newEditorValue = editorValue.substr(0, editorCursorIndex) + "<" + propertyName + ">" + editorValue.substr(editorCursorIndex);
        editorModel.setValue(newEditorValue);
        var newEditorCursorIndex = editorModel.getPositionAt(editorCursorIndex + propertyName.length + 2);
        this.monacoEditor.setPosition(newEditorCursorIndex);
        this.monacoEditor.focus();
    }

}

export interface TreeComponentDataDecorator {
    updateTree(root: ConceptNodeInput, context: NodeFactoryContext): void;
}

export class PropertyFilterDecorator implements TreeComponentDataDecorator {

    updateTree(root: ConceptNodeInput, context: NodeFactoryContext) {
        var searchText = context.propertyAutocompleteOptions.searchText;
        if (context.propertyAutocompleteOptions.searchText.length > 0) {
            searchText = searchText.toLowerCase();
            var autocompleteClasses = _(root.concepts)
                .map(x => x.classes)
                .flatten<AutocompleteClass>()
                .value();

            autocompleteClasses.forEach(autocompleteClass => {
                autocompleteClass.properties = autocompleteClass.properties.filter(property => property.name.toLowerCase().indexOf(searchText) != -1)
            });
        }
    }
}

export class EmptyNodesFilterDecorator implements TreeComponentDataDecorator {

    updateTree(root: ConceptNodeInput, context: NodeFactoryContext) {
        var isClassWithoutPropertiesShown = context.propertyAutocompleteOptions.isClassWithoutPropertiesShown;
        if (!isClassWithoutPropertiesShown) {
            root.concepts.forEach(autocompleteConcept =>
                autocompleteConcept.classes = autocompleteConcept.classes.filter(autocompleteClass => autocompleteClass.properties.length > 0)
            );
            root.concepts = root.concepts.filter(autocompleteConcept => autocompleteConcept.classes.length > 0);
        }
    }
}

@observer
export class TreeComponent extends React.Component<TreeProps, any> {
    nodeFactories: INodeFactoryCommon[];
    dataDecorators: TreeComponentDataDecorator[];
    isNodeFactoryActiveVector: boolean[];


    constructor() {
        super();
        this.nodeFactories = [new ConceptNodeFactory(), new ClassNodeFactory(), new PropertyNodeFactory()];
        this.dataDecorators = [new PropertyFilterDecorator(), new EmptyNodesFilterDecorator()];
    }

    cloneTree(root: ConceptNodeInput): ConceptNodeInput {
        var concepts = root.concepts.map(autocompleteConcept => {
            var classes = autocompleteConcept.classes.map(autocompleteClass => {
                var properties = autocompleteClass.properties.map(autocompleteProperty => {
                    var newAutocompleteProperty = new OntologyProperty(autocompleteProperty.name);
                    newAutocompleteProperty.domain = autocompleteProperty.domain;
                    newAutocompleteProperty.range = autocompleteProperty.range;
                    return autocompleteProperty;
                });
                return {
                    name: autocompleteClass.name,
                    properties: properties
                };
            });
            return {
                classes: classes
            };
        });
        return { concepts: concepts };
    }

    applyDecorators(root: ConceptNodeInput, context: NodeFactoryContext): ConceptNodeInput {
        ;
        var currentRoot = root;
        for (var dataDecorator of this.dataDecorators) {
            currentRoot = this.cloneTree(currentRoot);
            dataDecorator.updateTree(currentRoot, context);
        }
        return currentRoot;
    }

    render() {
        var options = this.props.propertyAutocompleteOptions;
        var searchText = options.searchText;
        this.isNodeFactoryActiveVector = [options.isOntologyConceptShown, options.isOntologyClassShown, true];
        var context = new NodeFactoryContext(this.props.monacoEditor, this.nodeFactories, this.isNodeFactoryActiveVector, this.props.propertyAutocompleteOptions);
        return context.renderListUnder(this.applyDecorators(this.props.conceptNodeInput, context));
    }
}
