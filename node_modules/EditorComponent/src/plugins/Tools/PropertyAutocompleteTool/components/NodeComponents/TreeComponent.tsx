import * as React from "react";
import { observer } from "mobx-react";
import { List, ListItem, Divider, RaisedButton, Paper, Card, CardHeader, CardText } from "material-ui"
import { observable } from "mobx";
import { SparqlLanguageServer, OntologyAutocompleteSubProvider, OntologyConcept, OntologyProperty, OntologyHiearchy } from "SparqlAutocompletion";
import { CleanOntologyClassTextFormatter } from "SparqlAutocompletion";
import { IOntologyClass } from "SparqlAutocompletion";
import { INodeFactory, INodeFactoryCommon, INodeFactoryContext } from "./NodeFactory";
import { ConceptNodeInput } from "./DataModel";
import { ConceptNodeFactory } from "./ConceptNode";
import { ClassNodeFactory } from "./ClassNode";
import { PropertyNodeFactory } from "./PropertyNode";
import { PropertyAutocompleteOptions } from "../../PropertyAutocompleteOptions";

export interface TreeProps {
    conceptNodeInput: ConceptNodeInput;
    propertyAutocompleteOptions: PropertyAutocompleteOptions;
}

class NodeFactoryContext implements INodeFactoryContext {
    private index = 0;

    constructor(
        private nodeFactories: INodeFactoryCommon[],
        private isNodeFactoryActiveVector: boolean[],
        public propertyAutocompleteOptions: PropertyAutocompleteOptions) {
    }

    private cloneAndSetIndex(index: number) {
        var result = new NodeFactoryContext(this.nodeFactories,
            this.isNodeFactoryActiveVector,
            this.propertyAutocompleteOptions);
        result.index = index;
        return result;
    }

    renderListUnder(data: any): JSX.Element {
        for (var index = this.index; index < this.nodeFactories.length; index++) {
            var currentFactory = this.nodeFactories[index];

            if (this.isNodeFactoryActiveVector[index]) {
                return currentFactory.getListElementCommon(data, this.cloneAndSetIndex(index + 1));
            }
            else {
                data = currentFactory.dataSelectorCommon(data, this);
            }
        }
        throw new Error("No other factory.");
    }
}

@observer
export class TreeComponent extends React.Component<TreeProps, any> {
    nodeFactories: INodeFactoryCommon[];
    isNodeFactoryActiveVector: boolean[];


    constructor() {
        super();
        this.nodeFactories = [new ConceptNodeFactory(), new ClassNodeFactory(), new PropertyNodeFactory()];
    }

    render() {
        var options = this.props.propertyAutocompleteOptions;
        var searchText = options.searchText;
        this.isNodeFactoryActiveVector = [options.isOntologyConceptShown, options.isOntologyClassShown, true];
        var context = new NodeFactoryContext(this.nodeFactories, this.isNodeFactoryActiveVector, this.props.propertyAutocompleteOptions);
        return context.renderListUnder(this.props.conceptNodeInput);
    }
}
