import { RecoverableParserError, HaltingParserError } from "ERSParser";

export class ErrorMessageProvider {
    private monacoEditorModel: monaco.editor.IModel;

    init(monacoEditor: monaco.editor.IStandaloneCodeEditor): void {
        this.monacoEditorModel = monacoEditor.getModel();
    }

    findErrorNewStartOffset(editorContent: string, offsetOfStart: number, offsetOfEnd: number) {
        for (var i = offsetOfStart + 1; i < offsetOfEnd - 1; i++) {
            var currentChar = editorContent[i];
            if (currentChar != " " && currentChar != "\r" && currentChar != "\n") {
                return i;
            }
        }

        return offsetOfStart;
    }

    skipSpacesOnErrorBeginning(error: RecoverableParserError): monaco.Position {
        var editorModel = this.monacoEditorModel;
        var editorContent = editorModel.getValue();

        var offsetOfStart = editorModel.getOffsetAt(new monaco.Position(
            error.startTokenRange.last_line,
            error.startTokenRange.last_column));

        var offsetOfEnd = editorModel.getOffsetAt(new monaco.Position(
            error.endTokenRange.last_line,
            error.endTokenRange.last_column,
        ));

        var newStartOffset = this.findErrorNewStartOffset(editorContent, offsetOfStart, offsetOfEnd);
        var newStartPosition = editorModel.getPositionAt(newStartOffset);
        return newStartPosition;
    }

    setEditorErrors(recoverableErrors: RecoverableParserError[], haltingError: HaltingParserError) {

        var errorsMarkers = recoverableErrors.map(error => {
            var errorStartPosition = this.skipSpacesOnErrorBeginning(error);
            return {
                severity: monaco.Severity.Error,
                code: '',
                source: '',
                startLineNumber: errorStartPosition.lineNumber,
                startColumn: errorStartPosition.column,
                endLineNumber: error.endTokenRange.last_line,
                endColumn: error.endTokenRange.last_column,
                message: error.type,
            }
        });

        if (haltingError != null) {
            
            errorsMarkers.push({
                severity: monaco.Severity.Error,
                code: '',
                source: '',
                startLineNumber: haltingError.startTokenRange.last_line,
                startColumn: haltingError.startTokenRange.last_column,
                endLineNumber: haltingError.endTokenRange.last_line,
                endColumn: haltingError.endTokenRange.last_column,
                message: haltingError.message,
            });
        }
        monaco.editor.setModelMarkers(this.monacoEditorModel, 'sparql', errorsMarkers);
    }
}