import { ParserError } from "ERSParser";
import { ParserErrorStore } from "../store/ParserErrorsStore";

export class ErrorMessageProvider {
    private monacoEditorModel: monaco.editor.IModel;

    constructor(private parserErrorStore: ParserErrorStore) {

    }

    init(monacoEditor: monaco.editor.IStandaloneCodeEditor): void {
        this.monacoEditorModel = monacoEditor.getModel();
    }

    findErrorNewStartOffset(editorContent: string, offsetOfStart: number, offsetOfEnd: number) {
        for (var i = offsetOfStart + 1; i < offsetOfEnd - 1; i++) {
            var currentChar = editorContent[i];
            if (currentChar != " " && currentChar != "\r" && currentChar != "\n") {
                return i;
            }
        }

        return offsetOfStart;
    }

    skipSpacesOnErrorBeginning(error: ParserError): monaco.Position {
        var editorModel = this.monacoEditorModel;
        var editorContent = editorModel.getValue();

        var offsetOfStart = editorModel.getOffsetAt(new monaco.Position(
            error.range.first_line,
            error.range.first_column + 1));

        var offsetOfEnd = editorModel.getOffsetAt(new monaco.Position(
            error.range.last_line,
            error.range.last_column + 1,
        ));

        var newStartOffset = this.findErrorNewStartOffset(editorContent, offsetOfStart, offsetOfEnd);
        var newStartPosition = editorModel.getPositionAt(newStartOffset);
        return newStartPosition;
    }

    setEditorErrors(recoverableErrors: ParserError[], haltingError: ParserError) {

        var errorsMarkers = recoverableErrors.map(error => {
            var errorStartPosition = this.skipSpacesOnErrorBeginning(error);
            return {
                severity: monaco.Severity.Error,
                code: '',
                source: '',
                startLineNumber: errorStartPosition.lineNumber,
                startColumn: errorStartPosition.column,
                endLineNumber: error.range.last_line,
                endColumn: error.range.last_column + 1,
                message: error.message,
            }
        });

        if (haltingError != null) {
            errorsMarkers.push({
                severity: monaco.Severity.Error,
                code: '',
                source: '',
                startLineNumber: haltingError.range.first_line,
                startColumn: haltingError.range.first_column + 1,
                endLineNumber: haltingError.range.last_line,
                endColumn: haltingError.range.last_column + 1,
                message: haltingError.message,
            });
        }
        monaco.editor.setModelMarkers(this.monacoEditorModel, 'sparql', errorsMarkers);
        this.parserErrorStore.containsHaltingError = haltingError != null;
        this.parserErrorStore.errors = errorsMarkers.map(x =>
            "On line " + x.startLineNumber + ":    " + x.message
        );
    }
}