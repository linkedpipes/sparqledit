import { EditorSettingsStore } from '../store/EditorSettingsStore';
import { observable } from "mobx";
var ERSParser = require('ERSParser');

export class ParserResultStore {
    @observable.ref result: iresult;
}

export interface iresult {
    parserResult: string;
    lexerOutput: string;
    lexerErrorOutput: string;
    parserErrorOutput: { message: string, tracedParserErrors: any };
    parserErrors: any[];
    parserLog: any;
    parserOutput: string;
}

export class ParsingService {
    private parser = new ERSParser();
    constructor(private editorSettingsStore: EditorSettingsStore) {

    }

    run(query: string) {
        return this.runParser(query);
    }

    removeKeysFromStack(stack: any) {
        return Object.keys(stack).map(function (x) {
            return stack[x];
        });
    }

    setParserResultInScope(result: iresult, parserResult: any) {
        var parserErrors = [];
        if (parserResult.parserErrors) {
            parserErrors = parserResult.parserErrors;
            delete parserResult.parserErrors;
        }
        result.parserOutput = parserResult;
        result.parserErrors = parserErrors;
    }


    runLexer(quer: string): { lexerOutput: string, lexerErrorOutput: string } {
        var result: { lexerOutput: string, lexerErrorOutput: string } = { lexerOutput: null, lexerErrorOutput: null };
        if (true) {
            try {
                result.lexerOutput = this.parser.showTerminals(quer);
            }
            catch (error) {
                result.lexerOutput = null;
                result.lexerErrorOutput = error;
            }
        }
        return result;
    }

    runParser(query: string) {
        var result: iresult = {
            parserResult: null,
            lexerOutput: null,
            lexerErrorOutput: null,
            parserErrorOutput: { message: null, tracedParserErrors: null },
            parserErrors: [],
            parserLog: null,
            parserOutput: null
        }

        result.lexerErrorOutput = null;
        result.parserErrorOutput = null;

        var lexerResult = this.runLexer(query);
        result.lexerErrorOutput = lexerResult.lexerErrorOutput;
        result.lexerOutput = lexerResult.lexerOutput;
        try {
            var parserResult = this.parser.parse(query);
            this.setParserResultInScope(result, parserResult);
            result.parserLog = this.parser.parserDebugger;
        } catch (error) {
            result.parserLog = this.parser.parserDebugger;
            result.parserOutput = null;
            result.parserErrorOutput = {
                message: error.message,
                tracedParserErrors: this.parser.tracedParserErrors
            };
            if (this.parser.tracedParserErrors.length > 0) {
                var haltParserError = this.parser.tracedParserErrors[this.parser.tracedParserErrors.length - 1];
                var editorError = {
                    type: 'unnexpected ' + haltParserError.problemToken,
                    yylocStart: {
                        last_line: haltParserError.loc.first_line,
                        last_column: haltParserError.loc.first_column,
                        first_line: -1,
                        first_column: -1
                    },
                    yylocEnd: {
                        first_line: -1,
                        first_column: -1,
                        last_line: haltParserError.loc.last_line,
                        last_column: haltParserError.loc.last_column,
                    }
                };
                result.parserErrors = [editorError];
            };
        }
        return result;
    }
}