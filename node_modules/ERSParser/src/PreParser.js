var ParserError = require('./errors/ParserError').ParserError;
/**
 * Remove character from string at given position
 * @param {string} text 
 * @param {number} position of character
 * @returns {string} text without a removed character
 */
function removeCharacterAt(text, position) {
    return text.substring(0, position) + text.substring(position + 1, text.length);
}

/**
 * Insert text into string at given position
 * @param {string} text 
 * @param {number} position
 * @param {string} insertText
 * @returns {string} text with inserted text
 */
function insertTextAt(text, position, insertText) {
    return text.substring(0, position) + insertText + text.substring(position, text.length);
}

/**
 * Contains state and error logic of PreParser algorithm
 * @param {string} query
 */
function PreParserContext(lexer) {
    this.lexer = lexer;
    this.query = lexer._input;
    this.queryLength = this.query.length;
    this.currentTokenIndex = -1;
    this.openParenthesisCount = 0;
    this.openBracketsCount = 0;
    this.unclosedBrackets = [];
}

/**
 * Increase brackets count.
 */
PreParserContext.prototype.increaseBracketsCount = function () {
    this.openBracketsCount++;
}

/**
 * Decrease brackets count, but brackets count does not goes under 0. 
 */
PreParserContext.prototype.decreaseBracketsCount = function () {
    this.openBracketsCount--;
    if (this.openBracketsCount <= 0) {
        this.openBracketsCount = 0;
    }
}


/**
 * Checks closed brackets
 */
PreParserContext.prototype.checkClosedBrackets = function () {
    if (this.openBracketsCount > 0) {
        this.unclosedBrackets.push({
            position: Object.assign({}, this.lexer.yylloc),
            offset: this.queryLength - (this.lexer._input.length + this.lexer.yytext.length),
            count: this.openBracketsCount
        })
        this.openBracketsCount = 0;
    }
}

/**
 * Increase parenthesis count.
 */
PreParserContext.prototype.increaseParenthesisCount = function () {
    this.openParenthesisCount++;
}

/**
 * Decrease parenthesis count, but parenthesis count does not goes under 0. 
 */
PreParserContext.prototype.decreaseParenthesisCount = function () {
    this.openParenthesisCount--;
    if (this.openParenthesisCount < 0) {
        this.openParenthesisCount = 0;
    }
}

/**
 * Move position window in lexer. 
 * @returns {boolean} True if position is valid.
 */
PreParserContext.prototype.next = function () {
    this.currentTokenIndex = this.lexer.lex();
    return this.currentTokenIndex != 1;
}

/**
 * Returns current token
 */
PreParserContext.prototype.getCurrentToken = function () {
    return this.currentTokenIndex;
}

/**
 * Returns errors from preparsing.
 */
PreParserContext.prototype.getErrors = function () {
    var haltingError = null;
    var errors = [];
    if (this.openParenthesisCount > 0) {
        var error = new ParserError("MissingClosedParenthesis");
        error.options = {
            count: this.openParenthesisCount
        }
        errors.push(error);
    }
    this.unclosedBrackets.forEach(function (x) {
        var error = new ParserError('UnclosedBracket');
        error.options = {
            position: x.position,
            offset: x.offset
        }
        errors.push(error);
    });
    return { recoverableErrors: errors, haltingError: haltingError };
}

/**
 * Fix query from recoverable errors
 * @returns {string} fixed query
 */
PreParserContext.prototype.getFixedQuery = function () {
    var fixedQuery = this.query;
    for (var i = this.unclosedBrackets.length - 1; i >= 0; i--) {
        var unclosedBracket = this.unclosedBrackets[i];
        var insertedClosedBrackets = Array(unclosedBracket.count + 1).join(")");
        fixedQuery = insertTextAt(fixedQuery,
            unclosedBracket.offset,
            insertedClosedBrackets);
    }
    return fixedQuery + Array(this.openParenthesisCount + 1).join('}');
}

/**
 * Preparser handle errors with parenthesis count and open quotes.
 */
function PreParser() {
    // empty
}

/**
 * Runs preparsing
 * @param {Object} lexer
 * @param {Array} terminals array with names of terminals
 */
PreParser.prototype.run = function (lexer, terminals) {
    var context = new PreParserContext(lexer);
    while (context.next()) {
        var currentTokenIndex = context.getCurrentToken();
        var currentToken = terminals[currentTokenIndex];
        switch (currentToken) {
            case "{":
                context.increaseParenthesisCount();
                context.checkClosedBrackets();
                break;
            case "}":
                context.decreaseParenthesisCount();
                context.checkClosedBrackets();
                break;
            case '(':
                context.increaseBracketsCount();
                break;
            case ')':
                context.decreaseBracketsCount();
                break
            case 'VALUES':
            case 'BIND':
            case 'FILTER':
            case 'SERVICE':
            case 'GRAPH':
            case 'MINUS':
            case 'OPTIONAL':
            case 'ASC':
            case 'DESC':
            case 'WHERE':
            case 'FROM':
            case 'LIMIT':
            case 'OFFSET':
            case 'ORDER':
            case 'HAVING':
            case 'EOF':
                context.checkClosedBrackets();
                break;
            default:
            // anything
        }
    }

    var errors = context.getErrors();
    return {
        recoverableErrors: errors.recoverableErrors,
        haltingError: errors.haltingError,
        fixedQuery: context.getFixedQuery()
    }
}

module.exports.PreParser = PreParser