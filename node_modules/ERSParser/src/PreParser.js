var ParserError = require('./errors/ParserError').ParserError;

/**
 * Remove character from string at given position
 * @param {string} text 
 * @param {number} position of character
 * @returns {string} text without a removed character
 */
function removeCharacterAt(text, position) {
    return text.substring(0, position) + text.substring(position + 1, text.length);
}

/**
 * Contains state and error logic of PreParser algorithm
 * @param {string} query
 */
function PreParserContext(query) {
    this.query = query;
    this.queryLength = query.length;
    this.position = -1;
    this.openParenthesisCount = 0;
    this.removeCloseParenthesisFrom = [];
    this.isQuotesOpen = false;
    this.lastOpenQuotesPosition = -1;
    this.openQuotesCharacter = '';
}

/**
 * Sets current position into lastOpenQuotesPosition
 */
PreParserContext.prototype.setLastOpenQuotesPosition = function () {
    this.lastOpenQuotesPosition = this.position;
}

/**
 * Increase parenthesis count.
 */
PreParserContext.prototype.increaseParenthesisCount = function () {
    this.openParenthesisCount++;
}
/**
 * Decrease parenthesis count. In case of count goes under zero then sets count to 0
 * and adds current position into removeCloseParenthesisFrom.
 */
PreParserContext.prototype.decreaseParenthesisCount = function () {
    this.openParenthesisCount--;
    if (this.openParenthesisCount < 0) {
        this.removeCloseParenthesisFrom.push(this.position);
        this.openParenthesisCount = 0;
    }
}

/**
 * Move position window in query text. 
 * @returns {boolean} True if position is valid.
 */
PreParserContext.prototype.next = function () {
    this.position++;
    return this.position < this.queryLength;
}

/**
 * Must be called after iteration.
 * @param {number} end state id
 */
PreParserContext.prototype.end = function (state) {
    switch (state) {
        case 0:
            //ok 
            break;
        case 1:
            this.isQuotesOpen = true;
            this.openQuotesCharacter = '"';
            break;
        case 2:
            this.isQuotesOpen = true;
            this.openQuotesCharacter = '"';
            break;
        case 3:
            this.isQuotesOpen = true;
            this.openQuotesCharacter = "'";
            break;
        case 4:
            this.isQuotesOpen = true;
            this.openQuotesCharacter = "'";
            break;
        default:
            throw new Error('Unknown state.')
    }
}

PreParserContext.prototype.getErrors = function () {
    var haltingError = null;
    var errors = [];
    if (this.isQuotesOpen) {
        haltingError = new ParserError("MissingCloseQuotes");
        haltingError.options = {
            openQuotesCharacter: this.openQuotesCharacter,
            offset: this.lastOpenQuotesPosition
        };
        return { recoverableErrors: [], haltingError: haltingError };
    }

    if (this.openParenthesisCount > 0) {
        var error = new ParserError("MissingClosedParenthesis");
        error.options = {
            count: this.openParenthesisCount
        }
        errors.push(error);
    }

    return { recoverableErrors: errors, haltingError: haltingError };
}

/**
 * Fix query from recoverable errors
 * @returns {string} fixed query
 */
PreParserContext.prototype.getFixedQuery = function () {
    var fixedQuery = this.query;
    return fixedQuery + Array(this.openParenthesisCount + 1).join('}');
}

/**
 * Returns char from query at current position.
 * @returns {string} currentChar
 */
PreParserContext.prototype.currentChar = function () {
    return this.query[this.position];
}

/**
 *  Base state of PreParser, counts number of parenthesis, in case of quotes redirects to states handling quotes. 
 * @param {PreParserContext} context 
 */
function BaseState(context) {
    switch (context.currentChar()) {
        case '{':
            context.increaseParenthesisCount();
            return 0;
        case '}':
            context.decreaseParenthesisCount();
            return 0;
        case '"':
            context.setLastOpenQuotesPosition();
            return 1;
        case "'":
            context.setLastOpenQuotesPosition();
            return 3;
        default:
            return 0;
    }
}

/**
 * PreParser state handling double quotes.
 * @param {PreParserContext} context 
 */
function DoubleQuoteState(context) {
    switch (context.currentChar()) {
        case '"':
            return 0;
        case "\\":
            return 2;
        default:
            return 1;
    }
}

/**
 * PreParser state handling backslash (escape character) in double quotes.
 */
function DoubleQuoteSlashState() {
    return 1;
}

/**
 * PreParser state handling single quotes.
 * @param {PreParserContext} context 
 */
function SingleQuoteState(context) {
    switch (context.currentChar()) {
        case "'":
            return 0;
        case "\\":
            return 4;
        default:
            return 3;
    }
}

/**
 * PreParser state handling backslash (escape character) in single quotes.
 */
function SingleQuoteSlashState() {
    return 3;
}

/**
 * Preparser handle errors with parenthesis count and open quotes.
 */
function PreParser() {
    this.states = {
        0: BaseState,
        1: DoubleQuoteState,
        2: DoubleQuoteSlashState,
        3: SingleQuoteState,
        4: SingleQuoteSlashState
    };
}

PreParser.prototype.run = function (query) {
    var context = new PreParserContext(query);
    var state = 0;
    while (context.next()) {
        var stateStepFunction = this.states[state];
        state = stateStepFunction(context);
    }
    context.end(state);

    var errors = context.getErrors();
    return {
        recoverableErrors: errors.recoverableErrors,
        haltingError: errors.haltingError,
        fixedQuery: context.getFixedQuery()
    }
}

module.exports.PreParser = PreParser