var ParserError = require('./errors/ParserError').ParserError;
/**
 * Remove character from string at given position
 * @param {string} text 
 * @param {number} position of character
 * @returns {string} text without a removed character
 */
function removeCharacterAt(text, position) {
    return text.substring(0, position) + text.substring(position + 1, text.length);
}

/**
 * Contains state and error logic of PreParser algorithm
 * @param {string} query
 */
function PreParserContext(lexer) {
    this.lexer = lexer;
    this.query = lexer._input;
    this.currentTokenIndex = -1;
    this.openParenthesisCount = 0;
}

/**
 * Increase parenthesis count.
 */
PreParserContext.prototype.increaseParenthesisCount = function () {
    this.openParenthesisCount++;
}

/**
 * Decrease parenthesis count, but parenthesis count does not goes under 0. 
 */
PreParserContext.prototype.decreaseParenthesisCount = function () {
    this.openParenthesisCount--;
    if (this.openParenthesisCount < 0) {
        this.openParenthesisCount = 0;
    }
}

/**
 * Move position window in lexer. 
 * @returns {boolean} True if position is valid.
 */
PreParserContext.prototype.next = function () {
    this.currentTokenIndex = this.lexer.lex();
    return this.currentTokenIndex != 1;
}

/**
 * Returns current token
 */
PreParserContext.prototype.getCurrentToken = function () {
    return this.currentTokenIndex;
}

/**
 * Returns errors from preparsing.
 */
PreParserContext.prototype.getErrors = function () {
    var haltingError = null;
    var errors = [];
    if (this.openParenthesisCount > 0) {
        var error = new ParserError("MissingClosedParenthesis");
        error.options = {
            count: this.openParenthesisCount
        }
        errors.push(error);
    }
    return { recoverableErrors: errors, haltingError: haltingError };
}

/**
 * Fix query from recoverable errors
 * @returns {string} fixed query
 */
PreParserContext.prototype.getFixedQuery = function () {
    var fixedQuery = this.query;
    return fixedQuery + Array(this.openParenthesisCount + 1).join('}');
}

/**
 * Preparser handle errors with parenthesis count and open quotes.
 */
function PreParser() {
    // empty
}

/**
 * Runs preparsing
 * @param {Object} lexer
 * @param {Array} terminals array with names of terminals
 */
PreParser.prototype.run = function (lexer, terminals) {
    var context = new PreParserContext(lexer);
    while (context.next()) {
        var currentTokenIndex = context.getCurrentToken();
        var currentToken = terminals[currentTokenIndex];
        switch (currentToken) {
            case "{":
                context.increaseParenthesisCount();
                break;
            case "}":
                context.decreaseParenthesisCount();
                break;
            default:
            // anything
        }
    }

    var errors = context.getErrors();
    return {
        recoverableErrors: errors.recoverableErrors,
        haltingError: errors.haltingError,
        fixedQuery: context.getFixedQuery()
    }
}

module.exports.PreParser = PreParser