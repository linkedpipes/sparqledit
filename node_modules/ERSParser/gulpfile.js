var gulp = require('gulp');
var fs = require('fs');
var _ = require('underscore');
var exec = require('child_process').exec;
var spawn = require('child_process').spawn;
var mocha = require('gulp-mocha');
var clean = require('gulp-clean');
var jison = require('./gulp/gulp-jison/gulp-jison');
var rename = require('gulp-rename');
var replace = require('gulp-replace');
var browserify = require('gulp-browserify');
var simpleGit = require('simple-git');
var changeJisonParser = require('./gulp/jisonParserChanges/changeJisonParser')
var through = require("through2");

var allowedPathsToCommitOutOfMaster = ['src/parser.jison', 'test/queries'];
var parserInsertPartAnchor = 'var parser = {trace: function trace() { },';
var parserInsertPartSource = 'src/parserExtension.txt';

var createDebugParserModule = through.obj(function (chunk, encoding, done) {
    this.push(chunk);
    var newChunk = JSON.parse(JSON.stringify(chunk));
    newChunk.path = newChunk.path.replace("release", "debug");
    this.push(newChunk);
    return done();
})

gulp.task('clean', function () {
    return gulp.src(['generatedParser', 'bin'], { read: false })
        .pipe(clean());
});
gulp.task('buildJison', ['clean'], function () {
    var pipeResult = gulp.src('./src/parser.jison')
        .pipe(jison({ type: "slr" }))
        .pipe(gulp.dest('./generatedParser'));
    return pipeResult;
});

gulp.task('buildReleaseParser', ['clean', 'buildJison'], function () {
    var parserInsertPart = fs.readFileSync(parserInsertPartSource);
    var pipeResult = gulp.src('./generatedParser/parser.js')
        .pipe(rename('releaseParserModule.js'))
        .pipe(replace(parserInsertPartAnchor, parserInsertPartAnchor + parserInsertPart + ','))
        .pipe(changeJisonParser('release'))
        .pipe(gulp.dest('./generatedParser'));
});

gulp.task('buildDebugParser', ['clean', 'buildJison'], function () {
    var parserInsertPart = fs.readFileSync(parserInsertPartSource);
    var pipeResult = gulp.src('./generatedParser/parser.js')
        .pipe(rename('debugParserModule.js'))
        .pipe(replace(parserInsertPartAnchor, parserInsertPartAnchor + parserInsertPart + ','))
        .pipe(changeJisonParser('debug'))
        .pipe(gulp.dest('./generatedParser'));
});

gulp.task('buildParser', ['clean', 'buildJison', 'buildReleaseParser', 'buildDebugParser'], function () {
});

gulp.task('build', ['buildParser', 'browserify'], function () {

});

gulp.task('browserify', ['clean', 'buildParser'], function () {
    gulp.src(['src/ERSParser.js'])
        .pipe(browserify({ standalone: 'ERSParser' }))
        .pipe(gulp.dest('./bin'))
});

gulp.task('default', function () {
    console.log('There is no default action');
});

gulp.task('precommit', function () {
    var git = simpleGit('..');
    var branch;
    var diffSummary;
    var neco = git.branchLocal(function (err, summary) {
        branch = summary.current;
        console.log();
    })
        .diffSummary(['--cached'], function (err, summary) {
            diffSummary = summary;
        })
        .then(function () {
            if (branch == "master") {
                return;
            }
            var files = diffSummary.files;
            for (var i = 0; i < files.length; i++) {
                var currentFilePath = files[i].file;
                var result = _(allowedPathsToCommitOutOfMaster).any(function (allowedPath) {
                    return currentFilePath.match(allowedPath);
                });
                if (!result) {
                    console.log("Warning: you probably did not want commit", '\033[31m', currentFilePath, '\x1b[0m');
                }
            }
        });
});

gulp.task('default', function () {
    console.log('Default task is useless');
});